<div id="cnblogs_post_body"><p>来源：ANTLR中文网站：<a href="http://www.antlr.org.cn">http://www.antlr.org.cn</a></p> <p><b></b>&nbsp; <p>词法分析是编译过程的第一步，是编译过程的基础。词法分析除了上一章讲过它为语法分析提拱记号流，滤掉编译过程不关心的内容以外，还有一个重要的作用是有了词法分析可以大大提高编译的效率。可能有人曾有过疑问，为什么一定要有词法分析？词法分析和语法分析的关系与其它编译过程有些不同，如：语义分析，生成代码在编译过程中是独立的步骤与其它步骤有明显的区别。而词法分析和语法分析在形式上很相似，都要用文法去定义语言的结构。可以想象一下如果把词法分析和语法分析合并会有什么不同，也就是说我们直接对源代码做语法分析。如C#源代码中当我们遇到一个字符&#8220;c&#8221;这时它可能会是关键字&#8220;class&#8221;标识符&#8220;c1&#8221;等等。如果是class关键字那么接下是要分析一个类代码，如果是标识符那要看它的具体上下文而定。这样的话与一个字符&#8220;c&#8221;有可能对应的情况太多了。所以要先做一遍词法分析把源程序的基础组成单位先分析出来。词法分析是语法分析的一个缓冲，可以大大提高编译效率。  <p><b>3.1</b><b>词法分析的规定</b>  <p>与第二章中的例子不同，在ANTLR中词法分析定义的规则名必须以大写字母开头如&#8220;LETTER&#8221;，&#8220;NewLine&#8221;。我们在第一章示例中的词法分析部分与语法分析部分合写到一个E.g文件中，ANTLR允许把词法分析部分和语法分析写分别写到两个文件中。  <p>T.g文件存放语法定义：  <p>grammar T;  <p>Options {tokenVocab = T2;}  <p>a<b> : </b>B*;  <p>T2.g文件存放词法定义：  <p>lexer grammar T2;  <p>B<b> : </b>&#8216;b&#8217;;  <p>将词法分析放到单独的文件中时文法的名称也要和文件的名称相同，在grammar关键字之前要加入lexer关键字。上例中的T.g文件生成语法分析类TParser，T2.g文件生成词法分析类T2Lexer。在T.g中要加入一个设置项tokenVocab来指定语法文件所需的词法单词是来自T2.g。这样就可以按照第一章示例中的方法编译运行分析器了。  <p><b>3.2</b><b>字符编码定义</b>  <p>词法分析与源代码直接接触，因为源代码是由字符串组成的，所以我们需要定义字符的方法。ANTLR有两种方法定义字符，第一种方法是：ANTLR可以直接使用字符本身很简单直观的定义基本符号。  <p>CHAR<b> : </b>&#8216;a&#8217; | &#8216;b&#8217; | &#8216;c&#8217;;  <p>但这种定义只限于ASCII码的字符，下面的定义是不合法的。  <p>CHAR <b>:</b> &#8216;代码&#8217;;  <p>定义汉字这样除ASCII码以外的字符只能用第二种方法十六进制编码定义法。使用&#8220;\u&#8221;开头加四位十六进制数定义来定义一个字符。  <p>CHAR <b>:</b> &#8216;\u0040&#8217;;  <p>C#中使用String.Format("{0:x} {1:x}", Convert.ToInt32('代'), Convert.ToInt32('码'));可以获得汉字的编码。如上面的CHAR<b> : </b><b>&#8216;</b>代码&#8217;;我们可以定义为：  <p>CHAR <b>:</b> '\u4ee3' '\u7801';  <p>编码有很多种GB2312的编码范围是A1A1 ~ FEFE，去掉未定义的区域之后可以理解为实际编码范围是A1A1 ~ F7FE。GBK的整体编码范围是为8140 ~ FEFE。 BIG5字符编码范围是A140 ~ F97E。  <table cellspacing="0" cellpadding="0" border="1"> <tbody> <tr> <td valign="top" width="168"> <p><b>字符集</b></p></td> <td valign="top" width="288"> <p><b>编码范围</b></p></td></tr> <tr> <td valign="top" width="168"> <p>GB2312</p></td> <td valign="top" width="288"> <p>A1A1 ~ 7E7E</p></td></tr> <tr> <td valign="top" width="168"> <p>GBK</p></td> <td valign="top" width="288"> <p>8140 ~ FEFE</p></td></tr> <tr> <td valign="top" width="168"> <p>BIG5</p></td> <td valign="top" width="288"> <p>A140 ~ F97E</p></td></tr> <tr> <td valign="top" width="168"> <p>Unicode</p></td> <td valign="top" width="288"> <p>000000 ~ 10FFFF</p></td></tr> <tr> <td valign="top" width="168"> <p>UTF-8</p></td> <td valign="top" width="288"> <p>000000 ~ 10FFFF</p></td></tr></tbody></table> <p>其中汉字在GB2312中的编码范围为：&#8216;\uB0A1' .. '\uF7FE'，汉字在Unicode编码范围为：&#8217;\u4E00&#8217; .. &#8216;\u9FA5&#8217; | &#8216;\uF900&#8217; .. &#8216;\uFA2D&#8217;。  <p><b>3.3</b><b>终结符定义方法</b>  <p>LETTER<b> : </b>&#8216;A&#8217; | &#8216;B&#8217; | &#8216;C&#8217; | &#8216;D&#8217; | &#8216;E&#8217; | &#8216;F&#8217; | &#8216;G&#8217; | &#8216;H&#8217; | &#8216;I&#8217; | &#8216;J&#8217; | &#8216;K&#8217; | &#8216;L&#8217; | &#8216;M&#8217; | &#8216;N&#8217; | &#8216;O&#8217; | &#8216;P&#8217; | &#8216;Q&#8217; | &#8216;R&#8217; | &#8216;S&#8217; | &#8216;T&#8217; | &#8216;U&#8217; | &#8216;V&#8217; | &#8216;W&#8217; | &#8216;X&#8217; | &#8216;Y&#8217; | &#8216;Z&#8217; | &#8216;a&#8217; | &#8216;b&#8217; | &#8216;c&#8217; | &#8216;d&#8217; | &#8216;e&#8217; | &#8216;f&#8217; | &#8216;g&#8217; | &#8216;h&#8217; | &#8216;i&#8217; | &#8216;j&#8217; | &#8216;k&#8217; | &#8216;l&#8217; | &#8216;m&#8217; | &#8216;n&#8217; | &#8216;o&#8217; | &#8216;p&#8217; | &#8216;q&#8217; | &#8216;r&#8217; | &#8216;s&#8217; | &#8216;t&#8217; | &#8216;u&#8217; | &#8216;v&#8217; | &#8216;w&#8217; | &#8216;x&#8217; | &#8216;y&#8217; | &#8216;z&#8217;;  <p><b>&#8220;..&#8221;符号</b>，从上面的LETTER示例可以看出，定义一个表示英文字母的符号写起来非常繁琐。为了让定义变得简单ANTLR加入&#8220;..&#8221;符号通过指定首尾的字符可以很方便的定义一定范围内的字符。  <p>LETTER <b>:</b> &#8216;A&#8217; .. &#8216;Z&#8217; | &#8216;a&#8217; .. &#8216;z&#8217;;  <p><b>&#8220;~&#8221;符号，</b>如果我们想表示除某些符号以外的符号时，可以使用&#8220;~&#8221;符号。&#8220;~&#8221;代表取反的意思。  <p>A <b>:</b> ~ &#8216;B&#8217;;  <p>符号A匹配除字符&#8220;B&#8221;以外的所有字符。  <p>A <b>:</b> ~ (&#8216;A&#8217; | &#8216;B&#8217;); B <b>:</b> ~(&#8216;A&#8217; .. &#8216;B&#8217;); C <b>: </b>~&#8216;\u00FF';  <p>上面的例子中定义三个符号。符号A匹配除字符&#8220;A&#8221;和&#8220;B&#8221;以外的所有字符，符号B匹配除大写字符母以外的所有字符。符号C匹配除编码为&#8220;u00FF&#8221;的字符以外的所有字符。  <p><b>&#8220;.&#8221;符号，</b>ANTLR中可以用&#8220;.&#8221;表示单个任意字符，起通配符的作用。  <p>A<b> : </b>.; B<b> : </b>.*; C<b> : </b>.* &#8216;C&#8217;; D<b> : </b>~ .;//error  <p>上面的例子中符号A匹配一个任意字符，符号B符号匹配0到多个任意字符，符号C匹配0到多个任意字符直到遇到字符&#8220;C&#8221;为止。D的定义是错误的，不能定义任意字符以外的字符。  <p><b>3.4 skip()</b><b>方法</b>  <p>有些字符是不属于源程序范畴内的，这些字符在分析过程中应该忽略掉。在ANTLR中可以在词法定义中加入skip();，(如果是C#为目标语言为Skip();)。在规则的定义的之后与表示定义结束的分号之前加入&#8220;{skip();}&#8221;。例如下面定义了一个跳过空白的词法定义。  <p>WS <b>:</b> ( ' ' | '\t' | '\n' | '\r' ) + {skip();} ;  <p>空白符号WS中有空格符、制表符、回车和换行符，当遇到这些字符时词法分析程序会调用skip()方法跳过这些字符。  <p>B <b>:</b> 'A' | 'B' {Skip();} | 'C' ;  <p>上面的例子中符号B只在匹配字符&#8220;B&#8221;时跳过，从这个例子可以看出{Skip();}要写在忽略内容的后面，如果它处于某选择分支中那么它只对某分支起作用。下面我们定义一些实际中经常出现的词法定义。  <p>INT <b>:</b> DIGIT+;  <p>DIGIT <b>:</b> &#8216;0&#8217; .. &#8216;9&#8217;;  <p>INT 定义了整型数，整型数是由1个或多0到9的数字组成的。下面我们来定义浮点数，浮点数的整数部分至少要有一位数字，小数部分是可有可无的，如要有小数部分则至少要有1位小数位。  <p>FLOAT<b> : </b>DIGIT+ (<b>&#8216;.&#8217;</b> DIGIT+)?;  <p>下面是一个对于java语言中注释的定义。  <p>COMMENT : '/*' . * '*/' {skip();} ;  <p>LINE_COMMENT : '//' ~ ('\n' | '\r') * '\r'? '\n' {skip();} ;  <p>/* */ 和 // 代表的注释部分被忽略掉，下面我们给出完全的示例并运行它。  <p><b>grammar</b> T;  <p><b>options</b> {  <p>language=CSharp;  <p>output=AST;  <p>}  <p>a : INT;  <p>INT : DIGIT+;  <p>DIGIT <b>:</b> &#8216;0&#8217; .. &#8216;9&#8217;;  <p>COMMENT : '/*' . * '*/' {Skip();} ;  <p>LINE_COMMENT : '//' ~ ('\n' | '\r') * '\r'? '\n' {Skip();} ;  <p>WS : ( ' ' | '\t' | '\n' | '\r' ) + {Skip();} ;  <p>文法中的COMMENT、LINE_COMMENT和WS规则只是为了滤掉相应内容，没有必要与语法规则关联，这样它们也可以正确的工作。COMMENT符号使用了&#8220;.&#8221;符号来匹配一切字符直到匹配&#8220;/&#8221;字符为止。LINE_COMMENT从&#8220;//&#8221;字符开始匹配除了&#8220;\r\n&#8221;以外的所有字符直到匹配&#8220;\r\n&#8221;为止。其中有可以没有回车符只有换行符所以&#8220;\r&#8221;是可选项。  <p>将如下源代码保存到与exe同目录的f1.txt文件中。  <p>/* 这是  <p>注释 */  <p>234//这是注释  <p>/* 这是  <p>注释 */  <p>下面是运行分析器的代码。  <p>TestSkipLexer lex = new TestSkipLexer(new ANTLRFileStream("f1.txt"));  <p>CommonTokenStream tokenStream = new CommonTokenStream(lex);  <p>TestSkipParser parser = new TestSkipParser(tokenStream);  <p>TestSkipParser.a_return aReturn = parser.a();  <p>在Visual Studio.NET 2005中单步执行上面几行代码，当执行到TestSkipParser.a_return aReturn = parser.a();时用内存监视查看aReturn.Tree可以看到语法树中只有234一个子节点它的chinaren属性为空，这说明所有空白和注释的内容都被忽略了。  <p><b>3.5 $channel = HIDDEN</b>  <p>有时象注释这样的部分在编译时并不是完全放弃的，如java中在/**&#8230;.*/的注释形式中可以添加说明最终生成程序的文档，在.NET中使用 /// 注释形式也有类似的功能。也就是说我们在编译代码时忽略这些注释，而在分析生成文档时又要用到这些注释。这样的话就不能使用skip();方法了，skip()方法是抛弃其内容。所以ANTLR中加入了channel属性用来指定当前匹配的内容是属于哪一个频道，分析过程中关心哪个频道就可以只接收哪个频道的内容。ANTLR中定义有两个频道常量DEFAULT_CHANNEL和HIDDEN_CHANNEL，一般情况下匹配的内容都中放到DEFAULT_CHANNEL中。我们可以指定让当前匹配的内容放到哪个频道中。  <p>前面示例中的词法规则可以改成如下形式。  <p>COMMENT : '/*' . * '*/' {$channel=HIDDEN;} ;  <p>LINE_COMMENT : '//' ~ ('\n' | '\r') * '\r'? '\n' {$channel=HIDDEN;} ;  <p>WS : ( ' ' | '\t' | '\n' | '\r' ) + {$channel=HIDDEN;};  <p>COMMENT、LINE_COMMENT和WS词法规则后面加入{$channel=HIDDEN;}，这样匹配的字符就会被存放到HIDDEN频道中。下面将这个修改后的文法编译运行，其结果和使用skip()方法时是一样的。这就是说存在于HIDDEN频道中的内容被语法分析器忽略了，因为在默认情况下ANTLR语法分析程序只分析DEFAULT_CHANNEL中的内容。  <p>Channel这个概念是介于词法分析和语法分析之间的一个概念，将存放匹配的内容存放到各个频道中是在词法分析时进行的，而语法分析时可以有选择的读某一个频道中的内容。那么如何让语法分析程序处理示例中的注释内容呢？我们再次修改文法因为我们只关心注释所以把WS : ( ' ' | '\t' | '\n' | '\r' ) + {Skip();};改回成skip()方法因为空白我们是不关心的，下面给出全部的文法。  <p><b>grammar</b> TestHidden;  <p><b>options</b> {  <p>language=CSharp;  <p>output=AST;  <p>}  <p>a : b INT b;  <p>b : (COMMENT | LINE_COMMENT)*;  <p>INT : DIGIT+;  <p>DIGIT : '0' .. '9';  <p>COMMENT : '/*' . * '*/' {$channel=HIDDEN;} ;  <p>LINE_COMMENT : '//' ~ ('\n' | '\r') * '\r'? '\n' {$channel=HIDDEN;} ;  <p>WS : ( ' ' | '\t' | '\n' | '\r' ) + {Skip();} ;  <p>下面是运行代码，运行代码中加入了tokenStream.SetTokenTypeChannel方法。  <p>TestSkipLexer lex = new TestSkipLexer(new ANTLRFileStream("f1.txt"));  <p>CommonTokenStream tokenStream = new CommonTokenStream(lex);  <p>TestSkipParser parser = new TestSkipParser(tokenStream);  <p>tokenStream.SetTokenTypeChannel(TestSkipLexer.COMMENT, Token.DEFAULT_CHANNEL);  <p>tokenStream.SetTokenTypeChannel(TestSkipLexer.LINE_COMMENT, Token.DEFAULT_CHANNEL);  <p>TestSkipParser.a_return bReturn = parser.a();  <table cellspacing="0" cellpadding="0"> <tbody> <tr> <td width="24"></td></tr> <tr> <td></td> <td><a href="../../images/program/java/antlr/clip_image001_2.gif"><img title="clip_image001" style="border-right: 0px; border-top: 0px; display: inline; border-left: 0px; border-bottom: 0px" height="204" alt="clip_image001" src="../../images/program/java/antlr/clip_image001_thumb.gif" width="534" border="0"></a></td></tr></tbody></table><br>SetTokenTypeChannel方法是将指定的频道中的符号加入到分析程序关心的范围内，第一个参数是词法符号，第二个参数是这个符号所处频道。两条SetTokenTypeChannel语句将DEFAULT_CHANNEL 频道中的COMMENT、LINE_COMMENT加入到语法分析程序<a href="http://www.aisto.com/roeder/dotnet/Default.aspx?Target=code://Antlr3.Runtime:0.3.0.37313/Antlr.Runtime.CommonTokenStream/channelOverrideMap:System.Collections.IDictionary">channelOverrideMap</a>集合中，语法分析程序会分析<a href="http://www.aisto.com/roeder/dotnet/Default.aspx?Target=code://Antlr3.Runtime:0.3.0.37313/Antlr.Runtime.CommonTokenStream/channelOverrideMap:System.Collections.IDictionary">channelOverrideMap</a>集中注册的类型，此示例运行后的语法树有四个子节点：  <p><b>3.6 options {greedy=false;}</b>  <p>ANTLR词法分析中还可以加入greedy设置项，当greedy=true时当前规则会尽可能的匹配可以匹配的输入。ANTLR中默认情况greedy为true，所以COMMENT : '/*' . * '*/' {$channel=HIDDEN;} ;规则中符号&#8220;.&#8221;可以匹配&#8220;*/&#8221;字符，也就是说当遇到&#8220;*/&#8221;字符时它是匹配&#8220;.&#8221;还是匹配&#8217;*/&#8217;出现了二义的情况，前面的例子中已经显示出在这种情况下分析器是可以正确分析的，但加入greedy=false后可以消除这种二义性，就是说greedy=false时分析器遇到&#8220;*/&#8221;字符时会很确定的做为注释结束符号来匹配，这样的话就消除了二义性。  <p>COMMENT : '/*' ( options {greedy=false;} : . ) * '*/' {$channel=HIDDEN;} ;  <p>options {greedy=false;} : 是一种局部设置的写法，其格式为：( options {&#171;option-assignmen ts&#187;} : &#171;subrule-alternatives&#187; )。关键字options后面用&#8220;{}&#8221;将设置项括起来，使用&#8220;:&#8221;符号表示对后面部分进行设置，这种设置的方法必须在子规则中设置它只能在子规则中有效。如：'/*' options {greedy=false;} : . * '*/' 这样的定义是不无法的。  <p>下面给出一个更加明显的例子。  <p><b>grammar</b> TestGreedy;  <p><b>options</b> {  <p>language=CSharp;  <p>output=AST;  <p>}  <p>c : A B;  <p>A : 'a' 'b' ?;  <p>B : 'b';  <p>此例子中c规则有A和B两个词法符号，其中A匹配的是&#8220;a&#8221;或&#8220;ab&#8221;字符，B匹配的是&#8220;b&#8221;字符。这时会出现一个问题就是当输入为&#8220;ab&#8221;时这个&#8220;b&#8221;是规则A的b还是规则B的b，这属于二义性问题。此示例在实际运行时如果输入为&#8220;abb&#8221;时可以正确生成有两个子节点的语法树。  <p><a href="../../images/program/java/antlr/clip_image002_2.gif"><img title="clip_image002" style="border-right: 0px; border-top: 0px; display: inline; border-left: 0px; border-bottom: 0px" height="97" alt="clip_image002" src="../../images/program/java/antlr/clip_image002_thumb.gif" width="553" border="0"></a><br>如果输入为&#8220;ab&#8221;会出现MismatchedTokenException异常，因为现在分析器的greedy属性为true。这时分析器会尽可能的匹配输入的字符&#8220;ab&#8221;被规则A匹配，这时规则B就没有了可匹配的字符，所以出现了MismatchedTokenException异常。  <p>如果我们将规则A中可选的&#8217;b&#8217;定义为greedy=false;代码如下。  <p>c : A B;  <p>A : 'a' (options {greedy=false;} : 'b')?;  <p>B : 'b';  <p>当输入&#8220;ab&#8221;和&#8220;abb&#8221;时生成的语法树同样为：  <table cellspacing="0" cellpadding="0"> <tbody> <tr> <td width="12"></td></tr> <tr> <td></td> <td><a href="../../images/program/java/antlr/clip_image003_2.gif"><img title="clip_image003" style="border-right: 0px; border-top: 0px; display: inline; border-left: 0px; border-bottom: 0px" height="110" alt="clip_image003" src="../../images/program/java/antlr/clip_image003_thumb.gif" width="538" border="0"></a></td></tr></tbody></table><br>规则A中的&#8217;b&#8217;由于是可选项并且其后规则B中也需要匹配&#8217;b&#8217;字符所以在Greedy属性为false时规则A不去匹配字符&#8217;b&#8217;。这样输入的字符串中第一个&#8217;b&#8217;字符与规则B匹配，第二个&#8217;b&#8217;字符无处匹配。  <p><b>3.7</b><b>&#8220;.&#8221;相关注意</b>  <p>词法定义中有一些与通配符&#8220;.&#8221;有关的注意事项，下面给出一个示例。  <p>d <b>:</b> C ANY PLUS;  <p>C <b>:</b> 'c';  <p>PLUS <b>:</b> '+';  <p>ANY <b>:</b> ( options {greedy=false;} : . ) *;  <p>这个文法是要匹配输入字符&#8220;c&#8221;和&#8220;+&#8221;，字符&#8220;c&#8221;与&#8220;+&#8221;之间可以是一些不确定的内容所以用通配符&#8220;<b>.</b>&#8221;进行匹配，如前面学到的应该使用greedy=false设置。但是此文法运行时会出现死循环情况。我们可以使用其它方法改写定义，由于字符&#8220;c&#8221;与&#8220;+&#8221;之间不应该出现&#8220;c&#8221;与&#8220;+&#8221;字符，所以ANY规则可以修改成以下的定义方法。  <p>ANY <b>:</b> ~(C | PLUS)*;  <p>不过如何正确使用&#8220;<b>.</b>&#8221;通配符呢？在使用通配符定义规则时要在当前的规则中明确的指定开始和结束字符。前面的示例中定义/**/注释时就是指定了开始结束字符。本示例只能改成：  <p>d <b>: </b>CANYPLUS;  <p>CANYPLUS <b>:</b> &#8216;c&#8217; ( options {greedy=false;}<b> :</b> <b>. </b>) * &#8216;+&#8217;;  <p>所以&#8220;<b>.</b>&#8221;的使用范围是有限的。  <p><b>3.8 fragment</b><b>词法规则</b>  <p>ANTLR文法中语法规则是在词法规则基础上建立的。但不一定每个词法规则都会被语法规则直接使用。这就象一个类的公有成员和私有成员，公有成员是对外公开的会被外界直接调用。而私有成员不对外公开是由公有成员间接调用的。在词法规则中那些不会被语法规则直接调用的词法规则可以用一个fragment关键字来标识，fragment标识的规则只能为其它词法规则提供基础。  <p>grammar TestFragment;  <p>options {  <p>language=CSharp;  <p>output=AST;  <p>}  <p>a : INT;  <p>INT : DIGIT+;  <p>fragment DIGIT : '0' .. '9';  <p>此示例中词法符号INT定义了整型数，而DIGIT定义了一位数字。语法规则a对DIGIT规则的使用是间接的，这时使用fragment来标识DIGIT规则，DIGIT规则将不能被语法规则直接调用。如果如下例语法规则a直接调用DIGIT规则，运行时语法分析器会死循环。  <p>a : DIGIT;  <p>INT : DIGIT+;  <p>fragment DIGIT : '0' .. '9';  <p>在不使用fragment关键字的时候，有时语法规则也不能直接使用某些词法规则。请看下面的示例。  <p>a : DIGIT;  <p>INT : DIGIT+;  <p>DIGIT : '0' .. '9';  <p>运行后输入&#8220;9&#8221;分析器生成的语法树为空，使用java命令行运行时提示&#8220;line 1:0 mismatched input '0' expecting DIGIT &#8221;。这是因为DIGIT规则匹配的内容对INT规则来说也是匹配的，INT规则干扰了DIGIT规则的匹配，造成DIGIT规则没有匹配的内容。  <p>a : DIGIT;  <p>fragment INT : DIGIT+;  <p>DIGIT : '0' .. '9';  <p>如果在INT前加入fragment则分析器可以生成有一个节点&#8220;9&#8221; 的语法树，不过在实际中不应该这样定义。在第五章我们会学到fragment词法规则是可以带参数的，这样可以在词法分析的过程中灵活的控制，fragment词法规则具有更大的意义。  <p><b>3.9 filter=true</b>  <p>我们在分析源代码时有时只想获得其中一部分信息，例如：我们想知道一个java文件中的类的类名，类有哪些方法，方法的参数和返回值及其类型，属性及其类型和此类继承了什么类。但是我们必须写出java的全部文法才可以分析java文件，这很有难度也没有必要。ANTLR中加入了一个叫filter的设置项，filter为布尔类型默认为false。filter为true时词法分析器可以处于一种过滤状态，我们只需定义出我们关心部分的词法结构，其它部分全部被忽略掉。  <p>filter=true模式中的词法规则是有优先顺序的，写在最前面的词法规则优先级最高之后从高到低依次排列。这样规定是因为有些规则会被其它规则所包含造成一些规则无法被识别出来。请看下面的示例：  <p><b>lexer</b> <b>grammar</b> TestFilter;  <p><b>options</b> {  <p>filter=true;  <p>language=CSharp;  <p>}  <p>A : aText=AA{Console.Out.WriteLine("A: "+$aText.Text);};  <p>B : bText=BB{Console.Out.WriteLine("B: "+$bText.Text);};  <p>AA : 'ab';  <p>BB : 'a';  <p>执行代码为：  <p>ICharStream input = new ANTLRFileStream("t.txt");  <p>FuzzyJava2Lexer lex = new FuzzyJava2Lexer(input);  <p>ITokenStream tokens = new CommonTokenStream(lex);  <p>tokens.ToString();  <p>此文法中规则AA匹配字符串&#8220;ab&#8221;，规则BB匹配字符串&#8220;a&#8221;，规则AA包含规则BB。t.txt文件中的内容为&#8220;xxxxxxabxxxxx&#8221;。我们看一看是内容规则A匹配优先还是规则B优先匹配，这可以反应出优先关系。这个例中输出为：&#8220;A : ab&#8221;。这说明规则A优先匹配了。下面修改一下文法：  <p>B : bText=BB{Console.Out.WriteLine("B: "+$bText.Text);};  <p>A : aText=AA{Console.Out.WriteLine("A: "+$aText.Text);};  <p>BB : 'a';  <p>AA : 'ab';  <p>相同的输入这次输出为：B : a。这说明规则B优先匹配了。但是如果将规则BB改为匹配字符&#8220;b&#8221;则输出为&#8220;A : ab&#8221;。  <p>B : bText=BB{Console.Out.WriteLine("B: "+$bText.Text);};  <p>A : aText=AA{Console.Out.WriteLine("A: "+$aText.Text);}; //输出为 A : ab  <p>BB : 'b';  <p>AA : 'ab';  <p>下面给出一个从java文件中读取类，方法，属性信息的示例。  <p><b>lexer</b> <b>grammar</b> FuzzyJava2;  <p><b>options</b> {  <p>filter=true;  <p>}  <p>IMPORT <b>:</b> 'import' WS name=QIDStar WS? ';'  <p>{Console.Out.WriteLine("Import: "+$name.Text);};  <p>PACKAGE <b>:</b> 'package' WS name=QID WS?';'  <p>{Console.Out.WriteLine("Package: "+$name.Text);};  <p>CLASS <b>:</b> 'class' WS name=ID WS? ('extends' WS QID WS?)?  <p>('implements' WS QID WS? (',' WS? QID WS?)*)? '{'  <p>{Console.Out.WriteLine("Class: "+$name.Text);};  <p>METHOD <b>:</b> type1=TYPE WS name=ID WS?  <p>'(' ( ARG WS? (',' WS? ARG WS?)* )? ')' WS?  <p>('throws' WS QID WS? (',' WS? QID WS?)*)? '{'  <p>{Console.Out.WriteLine("Method: "+type1.Text+" "+$name.Text + "()");};  <p>FIELD <b>:</b> defvisi=DEFVISI WS TYPE WS name=ID '[]'? WS? (';'|'=')  <p>{Console.Out.WriteLine("Field:"+$defvisi.Text+" "+$name.Text+";");};  <p>DEFVISI <b>:</b> 'public' | 'protected' | 'private';  <p>USECOMMENT <b>:</b> '/**' (options {greedy=false;} : . )* '*/' ;  <p>COMMENT <b>:</b> '/*' (options {greedy=false;} : . )* '*/'  <p>//{Console.Out.WriteLine("found comment "+Text);};  <p>SL_COMMENT <b>:</b> '//' (options {greedy=false;} : . )* '\r'?'\n' ;  <p>WS <b>:</b> (' '|'\t'|'\r'|'\n' )+ ;  <p>STRING <b>:</b> '"' (options {greedy=false;}: ESC | .)* '"';  <p>CHAR <b>:</b> '\'' (options {greedy=false;}: ESC | .)* '\'';  <p><b></b> <p><b>fragment</b> QID <b>:</b> ID ('.' ID)*;  <p><b>fragment</b> QIDStar <b>:</b> ID ('.' ID)* '.*'? ;  <p><b>fragment</b> TYPE <b>:</b> QID '[]'?;  <p><b>fragment</b> ARG <b>:</b> type=TYPE WS name=ID  <p>{Console.Out.WriteLine("Param: "+$type.Text + " "+$name.Text + " , ");};  <p><b>fragment</b> ID <b>:</b> ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;  <p><b>fragment</b> ESC <b>:</b> '\\' ('"'|'\''|'\\');  <p>分析此java源代码。  <p>/* [The "BSD licence"] Copyright (c) 2005-2006 Terence Parr  <p>All rights reserved.*/  <p>package org.antlr.analysis;  <p>import org.antlr.misc.IntSet;  <p>import org.antlr.misc.OrderedHashSet;  <p>import org.antlr.misc.Utils;  <p>import org.antlr.tool.Grammar;  <p>import java.util.*;  <p>public class DFAState extends State {  <p>public DFA dfa;  <p>public DFAState(DFA dfa) {  <p>this.dfa = dfa;  <p>}  <p>public int addTransition(DFAState target, Label label) {  <p>transitions.add( new Transition(label, target) );  <p>return transitions.size()-1;  <p>}  <p>/** Print all NFA states plus what alts they predict */  <p>public int getLookaheadDepth() {  <p>return k;  <p>}  <p>public void setLookaheadDepth(int k) {  <p>this.k = k;  <p>if ( k &gt; dfa.max_k ) { // track max k for entire DFA  <p>dfa.max_k = k;  <p>}  <p>}  <p>}  <p>如果将上面的java程序分析后会输出下面的结果。  <p>Package: org.antlr.analysis  <p>Import: org.antlr.misc.IntSet  <p>Import: org.antlr.misc.OrderedHashSet  <p>Import: org.antlr.misc.Utils  <p>Import: org.antlr.tool.Grammar  <p>Import: java.util.*  <p>Class: DFAState  <p>Field:public dfa;  <p>Param: DFA dfa ,  <p>Method: public DFAState()  <p>Param: DFAState target ,  <p>Param: Label label ,  <p>Method: int addTransition()  <p>Method: int getLookaheadDepth()  <p>Param: int k ,  <p>Method: void setLookaheadDepth()  <p><b>3.10</b><b>常用词法规则</b>  <p>下面给出一组很常用的词法定义规则：  <p><b>grammar</b> Abstract;  <p>NAME :  <p>(LETTER | UNDERLINE | CHINESECHAR)  <p>(LETTER | UNDERLINE | DIGIT | CHINESECHAR)* ;  <p>LETTER : ('A'..'Z' | 'a'..'z');  <p>CHINESECHAR : '\u4E00' .. '\u9FA5' | '\uF900' .. '\uFA2D';  <p>INT : DIGIT+;  <p>DIGIT : '0' .. '9';  <p>COLON : ':' ;  <p>COMMA : ',' ;  <p>SEMICOLON : ';' ;  <p>LPAREN : '(' ;  <p>RPAREN : ')' ;  <p>LSQUARE : '[' ;  <p>RSQUARE : ']' ;  <p>LCURLY : '{';  <p>RCURLY : '}';  <p>DOT : '.' ;  <p>UNDERLINE : '_';  <p>ASSIGNEQUAL : '=' ;  <p>NOTEQUAL1 : '&lt;&gt;' ;  <p>NOTEQUAL2 : '!=' ;  <p>LESSTHANOREQUALTO1 : '&lt;=' ;  <p>LESSTHAN : '&lt;' ;  <p>GREATERTHANOREQUALTO1 : '&gt;=' ;  <p>GREATERTHAN : '&gt;' ;  <p>DIVIDE : '/' ;  <p>PLUS : '+' ;  <p>MINUS : '-' ;  <p>STAR : '*' ;  <p>MOD : '%' ;  <p>AMPERSAND : '&amp;' ;  <p>TILDE : '~' ;  <p>BITWISEOR : '|' ;  <p>BITWISEXOR : '^' ;  <p>POUND : '#';  <p>DOLLAR : '$';  <p>COMMENT : '/*' . * '*/' {$channel=HIDDEN;} ;  <p>LINE_COMMENT : '//' ~ ('\n' | '\r') * '\r'? '\n' {$channel=HIDDEN;} ;  <p>WS : ( ' ' | '\t' | '\n' | '\r' ) + {Skip();} ;  <p><b>3.11</b><b>大小写敏感</b>  <p>ANTLR中没有大小写是否敏感的设置项，所以只能象下面的词法规则这样定义大小写不敏感的单词。  <p>SELECT : ('S'|'s')('E'|'e')('L'|'l')('E'|'e')('C'|'c')('T'|'t') ;  <p>FROM : ('F'|'f')('R'|'r')('O'|'o')('M'|'m');  <p>还有一种方法是重载输入的Stream类的LA方法在其中将输入的内容大小写不敏感。  <p>package org.antlr.runtime;  <p>import java.io.*;  <p>/** @author Jim Idle */  <p>public class ANTLRNoCaseFileStream extends ANTLRFileStream {  <p>public ANTLRNoCaseFileStream(String fileName) throws IOException {  <p>super(fileName, null);  <p>}  <p>public ANTLRNoCaseFileStream(String fileName, String encoding)  <p>throws IOException {  <p>super(fileName, encoding);  <p>}  <p>public int LA(int i) {  <p>if ( i==0 ) {  <p>return 0; // undefined  <p>}  <p>if ( i&lt;0 ) {  <p>i++; // e.g., translate LA(-1) to use offset 0  <p>}  <p>if ( (p+i-1) &gt;= n ) {  <p>return CharStream.EOF;  <p>}  <p>return Character.toUpperCase(data[p+i-1]);  <p>}  <p>}  <p>C#代码如下：（注 可是在lookahead时临时转换成小写，原来输入字符不会受到影响。）  <p>public class CaseInsensitiveStringStream : ANTLRStringStream {  <p>public CaseInsensitiveStringStream(char\[\] data, int numberOfActualCharsInArray) : base(data, numberOfActualCharsInArray) {}  <p>public CaseInsensitiveStringStream() {}  <p>public CaseInsensitiveStringStream(string input) : base(input) {}  <p>public override int LA(int i) {  <p>if (i == 0) {  <p>return 0;  <p>}  <p>if (i &lt; 0) {  <p>i++;  <p>}  <p>if (((p + i) - 1) &gt;= n) {  <p>return (int) CharStreamConstants.EOF;  <p>}  <p>return Char.ToLowerInvariant(data\[(p + i) - 1\]);  <p>}  <p>}  <p><b>3.11</b><b>本章小结</b>  <p>本章讲述了ANTLR如何定义词法规则，包括：定义各种编码的字符，通配符&#8220;.&#8221;和&#8220;..&#8221;、&#8220;~&#8221;、&#8220;.&#8221;符号的用法，skip()方法的用法，$channel = HIDDEN输入频道，greedy=false的用法和注意事项，fragment词法规则的用法。这些内容为ANTLR中词法分析中基础，后面章节还会讲述词法规则中潜入代码和词法中的二义性的内容。学完本章后读者应该可以定义一种语言的基本词法规则，下一章我们讲述如何在词法规则的基础上定义语法规则的内容。   </div>