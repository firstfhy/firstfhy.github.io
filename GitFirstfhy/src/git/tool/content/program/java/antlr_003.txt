<h2 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: 'Calibri Light', sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">1&nbsp;</span><span style="font-family: 微软雅黑, sans-serif;">重逢<span lang="EN-US">ANTLR</span></span></h2><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">最早知道<span lang="EN-US">ANTLR</span>是当年学习<span lang="EN-US">Apache Derby</span>数据库源码时，在看到<span lang="EN-US">SQL</span>解析那一层时，第一次看到编译原理在实际项目中的应用，惊叹之余也只能望而却步。之前也根据网上一些</span><span lang="EN-US"><a target=_blank href="http://blog.csdn.net/dc_726/article/details/12952395" style="color: rgb(149, 79, 114);"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">资料</span></a></span><span style="font-family: 微软雅黑, sans-serif;">尝试了一下，看介绍说<span lang="EN-US">ANTLR v4</span>更加易用了，于是又好奇地试用一下。以下入门介绍主要参考<span lang="EN-US">ANTLR</span>作者写的<em>《<span lang="EN-US">The Definitive ANTLR 4 Reference</span>》</em>。</span></p><h3 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">1.1 ANTLR</span><span style="font-family: 微软雅黑, sans-serif;">全景</span></h3><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">当我们实现一种语言时，我们需要构建读取句子（<span lang="EN-US">sentence</span>）的应用，并对输入中的元素做出反应。如果应用计算或执行句子，我们就叫它<strong>解释器（<span lang="EN-US">interpreter</span>）</strong>，包括计算器、配置文件读取器、<span lang="EN-US">Python</span>解释器都属于解释器。如果我们将句子转换成另一种语言，我们就叫它<strong>翻译器（<span lang="EN-US">translator</span>）</strong>，像<span lang="EN-US">Java</span>到<span lang="EN-US">C#</span>的翻译器和编译器都属于翻译器。不管是解释器还是翻译器，应用首先都要识别出所有有效的句子、词组、字词组等，识别语言的程序就叫<strong>解析器（<span lang="EN-US">parser</span>）</strong>或<strong>语法分析器（<span lang="EN-US">syntax analyzer</span>）</strong>。我们学习的重点就是如何实现自己的解析器，去解析我们的目标语言，像<span lang="EN-US">DSL</span>语言、配置文件、自定义<span lang="EN-US">SQL</span>等等。</span></p><h3 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">1.2&nbsp;</span><span style="font-family: 微软雅黑, sans-serif;">元编程</span></h3><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">手动编写解析器是非常繁琐的，所以我们有了<span lang="EN-US">ANTLR</span>。只需编写<span lang="EN-US">ANTLR</span>的语法文件，描述我们要解析的语言的语法，之后<span lang="EN-US">ANTLR</span>就会自动生成能解析这种语言的解析器。也就是说，<span lang="EN-US">ANTLR</span>是一种能写出程序的程序。在学习<span lang="EN-US">LISP</span>或<span lang="EN-US">Ruby</span>的宏时，我们经常能接触到元编程的概念。而用来声明我们语言的<span lang="EN-US">ANTLR</span>语言的语法，就是<strong>元语言（<span lang="EN-US">meta-language</span>）</strong>。</span></p><h3 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">1.3&nbsp;</span><span style="font-family: 微软雅黑, sans-serif;">解析过程</span></h3><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">为了简单起见，我们将解析分为两个阶段，对应我们的大脑读取文字时的过程。当我们读到一个句子时，在第一阶段，大脑会下意识地将字符组成单词，然后像查词典一样识别出它们的意思。在第二阶段，大脑会根据已识别的单词去识别句子的结构。第一阶段的过程叫<strong>词法分析（<span lang="EN-US">lexical analysis</span>）</strong>，对应的分析程序叫做<strong><span lang="EN-US" style="color: red;">lexer</span></strong>，负责将符号（<span lang="EN-US">token</span>）分组成<strong>符号类（<span lang="EN-US">token class or token type</span>）</strong>。而第二阶段就是真正的<strong><span lang="EN-US" style="color: red;">parser</span></strong>，默认<span lang="EN-US">ANTLR</span>会构建出一棵<strong>分析树（<span lang="EN-US">parse tree</span>）</strong>或叫<strong>语法树（<span lang="EN-US">syntax tree</span>）</strong>。如下图，就是简单的赋值表达式的解析过程：</span></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><br /></p><p style="text-align: center; orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; font-size: 10.5pt; font-family: Calibri, sans-serif;"><img src="http://img.blog.csdn.net/20150430212251393?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGNfNzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></p><p align="center" style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: center; font-size: 10.5pt; font-family: Calibri, sans-serif;"><img src="../../images/program/java/antlr/image001.png" style="cursor: default;" alt="" /></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">语法树的叶子是输入<span lang="EN-US">token</span>，而上级结点时包含其孩子结点的词组名（<span lang="EN-US">phase</span>），线性的句子其实是语法树的序列化。最终生成语法树的好处是：</span></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt 39pt; text-align: justify; text-indent: -18pt; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">1）<span style="font-size: 7pt; font-family: 'Times New Roman';">&nbsp;</span></span><span style="font-family: 微软雅黑, sans-serif;">树形结构易于遍历和处理，并且易被程序员理解，方便了应用代码做进一步处理。</span></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt 39pt; text-align: justify; text-indent: -18pt; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">2）<span style="font-size: 7pt; font-family: 'Times New Roman';">&nbsp;</span></span><span style="font-family: 微软雅黑, sans-serif;">多种解释或翻译的应用代码都可以重用一个解析器。但<span lang="EN-US">ANTLR</span>也支持像传统解析器生成器那样，将应用处理代码嵌入到语法中。</span></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt 39pt; text-align: justify; text-indent: -18pt; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">3）<span style="font-size: 7pt; font-family: 'Times New Roman';">&nbsp;</span></span><span style="font-family: 微软雅黑, sans-serif;">对于因为计算依赖而需要多趟处理的翻译器来说，语法树非常有用！我们不用多次调用解析器去解析，只需高效地遍历语法树多次。</span></p><h3 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">1.4&nbsp;</span><span style="font-family: 微软雅黑, sans-serif;">深入<span lang="EN-US">ANTLR</span></span></h3><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">ANTLR</span><span style="font-family: 微软雅黑, sans-serif;">生成的解析器叫做<strong>递归下降解析器（<span lang="EN-US">recursive-descent parser</span>）</strong>，属于自顶向下解析器（<span lang="EN-US">top-down parser</span>）的一种。顾名思义，递归下降指的就是解析过程是从语法树的根开始向叶子（<span lang="EN-US">token</span>）递归，比较酷的是代码的调用图能与树结点对应上。还是以前面的赋值表达式解析为例，其递归下降解析器的代码大概是下面这个样子：</span></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><br /></p><p style="text-align: center; orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; font-size: 10.5pt; font-family: Calibri, sans-serif;"><img src="http://img.blog.csdn.net/20150430212423197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGNfNzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></p><p align="center" style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: center; font-size: 10.5pt; font-family: Calibri, sans-serif;"><img src="../../images/program/java/antlr/image003.png" style="cursor: default;" alt="" /></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">Assign</span><span style="font-family: 微软雅黑, sans-serif;">很简单，直接顺序读取输入字符，不用做任何选择。相比之下，根结点<span lang="EN-US">Stat</span>要复杂一些，因为它有多种选择。解析时，要<strong>向前看（<span lang="EN-US">lookahead</span>）</strong>一些字符才能确认走哪个分支代码，有时甚至要读取完所有输入才能预测出，而<span lang="EN-US">ANTLR</span>默默为我们处理了一切！</span></p><h3 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">1.5&nbsp;</span><span style="font-family: 微软雅黑, sans-serif;">解析树上的应用</span></h3><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">在内部，<span lang="EN-US">ANTLR</span>的数据结构会尽可能地共享数据来节约内存，这种考量在<span lang="EN-US">Nginx</span>的<span lang="EN-US">String</span>中也能看到。如下图所示，解析树的叶子节点指向<span lang="EN-US">Token</span>流中的<span lang="EN-US">Token</span>，而<span lang="EN-US">Token</span>中的起止字符索引指向字符流，而非拷贝子字符串。而像空格这种不与任何<span lang="EN-US">Token</span>相关的字符会直接被<span lang="EN-US">Lexer</span>丢弃掉。</span></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><br /></p><p style="text-align: center; orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; font-size: 10.5pt; font-family: Calibri, sans-serif;"><img src="http://img.blog.csdn.net/20150430212445973?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGNfNzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="font-family: Calibri, sans-serif; font-size: 14px; orphans: 2; text-align: center; widows: 2;" alt="" /><br /></p><p align="center" style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: center; font-size: 10.5pt; font-family: Calibri, sans-serif;"><img src="../../images/program/java/antlr/image005.png" style="cursor: default;" alt="" /></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">ANTLR</span><span style="font-family: 微软雅黑, sans-serif;">为每个<span lang="EN-US">Rule</span>都会生成一个<span lang="EN-US">Context</span>对象，它会记录识别时的所有信息。<span lang="EN-US">ANTLR</span>提供了<span lang="EN-US">Listener</span>和<span lang="EN-US">Visitor</span>两种遍历机制。<span lang="EN-US">Listener</span>是全自动化的，<span lang="EN-US">ANTLR</span>会主导深度优先遍历过程，我们只需处理各种事件就可以了。而<span lang="EN-US">Visitor</span>则提供了可控的遍历方式，我们可以自行决定是否显示地调用子结点的<span lang="EN-US">visit</span>方法。</span></p><p align="center" style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: center; font-size: 10.5pt; font-family: Calibri, sans-serif;"><img src="http://img.blog.csdn.net/20150430212446194?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGNfNzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></p><p align="center" style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: center; font-size: 10.5pt; font-family: Calibri, sans-serif;"><img src="http://img.blog.csdn.net/20150430212611508?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGNfNzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></p><p align="center" style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: center; font-size: 10.5pt; font-family: Calibri, sans-serif;"><img src="../../images/program/java/antlr/image009.png" style="cursor: default;" alt="" /></p><h3 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">1.6 ANTLR v4</span><span style="font-family: 微软雅黑, sans-serif;">新特性</span></h3><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">目前还未深入使用，对<span lang="EN-US">v4</span>的新特性了解的不多，摘录一段</span><span lang="EN-US"><a target=_blank href="http://www.cnblogs.com/laud/p/antlrv4_diff.html" style="color: rgb(149, 79, 114);"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;"><span lang="EN-US">“antlr v4</span></span><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;"><span lang="EN-US">新特性总结及与antlr v3</span></span><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;"><span lang="EN-US">的不同</span></span><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;"><span lang="EN-US">”</span></span></a></span><span style="font-family: 微软雅黑, sans-serif;">：</span></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt 18pt; text-align: justify; text-indent: -18pt; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">1）<span style="font-size: 7pt; font-family: 'Times New Roman';">&nbsp;</span></span><span style="font-family: 微软雅黑, sans-serif;">学习曲线低。<span lang="EN-US">antlr v4</span>相对于<span lang="EN-US">v3</span>，<span lang="EN-US">v4</span>更注重于用更接近于自然语言的方式去解析语言。比如运算符优先级，排在最前面的规则优先级最高；</span></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt 18pt; text-align: justify; text-indent: -18pt; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">2）<span style="font-size: 7pt; font-family: 'Times New Roman';">&nbsp;</span></span><span style="font-family: 微软雅黑, sans-serif;">层次更清晰、更易维护。引入访问者、监听器模式，使解析与应用代码分离；新増<span lang="EN-US">import</span>功能，<span lang="EN-US">lexer</span>、<span lang="EN-US">parser</span>可以成为公共组件，増加可复用性；</span></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt 18pt; text-align: justify; text-indent: -18pt; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">3）<span style="font-size: 7pt; font-family: 'Times New Roman';">&nbsp;</span></span><span style="font-family: 微软雅黑, sans-serif;">新算法。改进<span lang="EN-US">LL()</span>算法，使用新的<span lang="EN-US">Adative LL()</span>算法，在运行时动态分析语法，而<span lang="EN-US">LL(*)</span>需要静态分析语法，考虑各种语法的可能性。</span></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt 18pt; text-align: justify; text-indent: -18pt; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">4）<span style="font-size: 7pt; font-family: 'Times New Roman';">&nbsp;</span></span><span style="font-family: 微软雅黑, sans-serif;">新用法。引入了一些新用法，如<span lang="EN-US">rewrite the input stream</span>、<span lang="EN-US">sending token in different channels</span>、<span lang="EN-US">island grammars</span>、<span lang="EN-US">associativity</span>，可以更方便、灵活地在应用中处理解析对象。</span></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt 18pt; text-align: justify; text-indent: -18pt; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">5）<span style="font-size: 7pt; font-family: 'Times New Roman';">&nbsp;</span></span><span style="font-family: 微软雅黑, sans-serif;">性能。相对于<span lang="EN-US">v3</span>，解析代码跟应用代码都是自动生成的，而<span lang="EN-US">v4</span>分离了解析与应用代码的实现，应用代码的实现及性能则可以由开发人员自主地控制，但新算法据官方指引说会消耗一定的速度上的性能，因此提供了<span lang="EN-US">SLL()</span>、<span lang="EN-US">LL()</span>的开关，可通过<span lang="EN-US">api</span>控制。</span></p><h2 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: 'Calibri Light', sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">2&nbsp;</span><span style="font-family: 微软雅黑, sans-serif;">准备工作</span></h2><h3 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">2.1&nbsp;</span><span style="font-family: 微软雅黑, sans-serif;">安装<span lang="EN-US">IDE</span>插件</span></h3><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">我这里使用的是<span lang="EN-US">Intellij IDEA</span>，所以就去<span lang="EN-US">Plugins</span>中搜“<span lang="EN-US">ANTLR v4 grammar plugin</span>”插件，重启<span lang="EN-US">IDEA</span>即可使用。如果想在<span lang="EN-US">IDE</span>外使用，需要下载<span lang="EN-US">ANTLR</span>包，是<span lang="EN-US">JAVA</span>写成的，后面在<span lang="EN-US">IDEA</span>中的各种操作都可以手动执行命令来完成。</span></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;"><br /></span></p><p style="text-align: center; orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;"><img src="http://img.blog.csdn.net/20150430212700258?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGNfNzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></span></p><p align="center" style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: center; font-size: 10.5pt; font-family: Calibri, sans-serif;"><img src="../../images/program/java/antlr/image011.png" style="cursor: default;" alt="" /></p><h3 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">2.2&nbsp;</span><span style="font-family: 微软雅黑, sans-serif;">实用的小例子</span></h3><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">没有搜到很好的例子，偶然看到<em>《<span lang="EN-US">The Definitive ANTLR 4 Reference</span>》</em>中第三章的入门实例不错，就参照着动手实现一下。简单介绍一下这个实用的小程序是要做什么？</span><span style="font-family: 微软雅黑, sans-serif; font-size: 10.5pt;">我们将</span><span lang="EN-US" style="font-family: 微软雅黑, sans-serif; font-size: 10.5pt;">short[] data = {1, 2, 3}&nbsp;</span><span style="font-family: 微软雅黑, sans-serif; font-size: 10.5pt;">翻译成</span><span lang="EN-US" style="font-family: 微软雅黑, sans-serif; font-size: 10.5pt;">&nbsp;string data = &quot;\u0001\u0002\u0003&quot;</span></p><h2 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: 'Calibri Light', sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">3&nbsp;</span><span style="font-family: 微软雅黑, sans-serif;">动手实现解析器</span></h2><h3 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">3.1&nbsp;</span><span style="font-family: 微软雅黑, sans-serif;">编写<span lang="EN-US">.g4</span>文件</span></h3><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">创建一个文件，后缀名是<span lang="EN-US">g4</span>，只有这样在文件上点右键才能看到<span lang="EN-US">ANTLR</span>插件的菜单。</span></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;"><br /></span></p><p style="text-align: center; orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;"><img src="http://img.blog.csdn.net/20150430212635425?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGNfNzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></span></p><p align="center" style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: center; font-size: 10.5pt; font-family: Calibri, sans-serif;"><img src="../../images/program/java/antlr/image013.png" style="cursor: default;" alt="" /></p><h3 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">3.2&nbsp;</span><span style="font-family: 微软雅黑, sans-serif;">自动生成代码</span></h3><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">在<span lang="EN-US">.g4</span>文件上右键就能看到<span lang="EN-US">ANTLR</span>插件的两个菜单，分别用来配置<span lang="EN-US">ANTLR</span>生成工具的参数（在命令行中都有对应）和触发生成文件。首先选配置菜单，将目录选择到<span lang="EN-US">main/java</span>或<span lang="EN-US">test/java</span>。注意：<span lang="EN-US">ANTLR</span>会自动根据<span lang="EN-US">Package/namespace</span>的配置，生成出包的文件夹，不用预先创建出来。</span></p><p align="center" style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: center; font-size: 10.5pt; font-family: Calibri, sans-serif;"><img src="http://img.blog.csdn.net/20150430212656033?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGNfNzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></p><p align="center" style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: center; font-size: 10.5pt; font-family: Calibri, sans-serif;"><br /></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">之后就点生成菜单，于是就在我们配置的目录下，自动生成出的如下代码：</span></p><p style="text-align: center; orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;"><img src="http://img.blog.csdn.net/20150430212712272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGNfNzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></span></p><p align="center" style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: center; font-size: 10.5pt; font-family: Calibri, sans-serif;"><img src="../../images/program/java/antlr/image017.png" style="cursor: default;" alt="" /></p><h2 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: 'Calibri Light', sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">4&nbsp;</span><span style="font-family: 微软雅黑, sans-serif;">构建应用代码</span></h2><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">有了生成好的解析器，我们就可以在它上面构建出好玩的应用了。</span></p><h3 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">4.1 ANLTR</span><span style="font-family: 微软雅黑, sans-serif;">运行时</span></h3><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">在开始编写应用代码之前，我们要引入<span lang="EN-US">ANTLR</span>运行时。因为我们的解析器其实只是一堆回调<span lang="EN-US">hook</span>，真正的通用解析流程实现是在<span lang="EN-US">ANTLR runtime</span>包中。所以，以<span lang="EN-US">Maven</span>为例<span lang="EN-US">ANTLR v4</span>的依赖是：</span></p><pre style="orphans: 2; text-align: -webkit-auto; widows: 2;font-size:14px; margin: 0cm 0cm 0.0001pt; font-family: 宋体; background-color: rgb(64, 64, 64);"><span lang="EN-US" style="font-size: 10pt; color: white;">&lt;</span><span lang="EN-US" style="font-size: 10pt; color: rgb(239, 239, 175);">dependency</span><span lang="EN-US" style="font-size: 10pt; color: white;">&gt;
    &lt;</span><span lang="EN-US" style="font-size: 10pt; color: rgb(239, 239, 175);">groupId</span><span lang="EN-US" style="font-size: 10pt; color: white;">&gt;</span><span lang="EN-US" style="font-size: 10pt; color: rgb(246, 243, 232);">org.antlr</span><span lang="EN-US" style="font-size: 10pt; color: white;">&lt;/</span><span lang="EN-US" style="font-size: 10pt; color: rgb(239, 239, 175);">groupId</span><span lang="EN-US" style="font-size: 10pt; color: white;">&gt;
    &lt;</span><span lang="EN-US" style="font-size: 10pt; color: rgb(239, 239, 175);">artifactId</span><span lang="EN-US" style="font-size: 10pt; color: white;">&gt;</span><span lang="EN-US" style="font-size: 10pt; color: rgb(246, 243, 232);">antlr4-runtime</span><span lang="EN-US" style="font-size: 10pt; color: white;">&lt;/</span><span lang="EN-US" style="font-size: 10pt; color: rgb(239, 239, 175);">artifactId</span><span lang="EN-US" style="font-size: 10pt; color: white;">&gt;
    &lt;</span><span lang="EN-US" style="font-size: 10pt; color: rgb(239, 239, 175);">version</span><span lang="EN-US" style="font-size: 10pt; color: white;">&gt;</span><span lang="EN-US" style="font-size: 10pt; color: rgb(246, 243, 232);">4.5</span><span lang="EN-US" style="font-size: 10pt; color: white;">&lt;/</span><span lang="EN-US" style="font-size: 10pt; color: rgb(239, 239, 175);">version</span><span lang="EN-US" style="font-size: 10pt; color: white;">&gt;
&lt;/</span><span lang="EN-US" style="font-size: 10pt; color: rgb(239, 239, 175);">dependency</span><span lang="EN-US" style="font-size: 10pt; color: white;">&gt;</span></pre><h3 style="orphans: 2; widows: 2; margin: 13pt 0cm; text-align: justify; line-height: 36.90666961669922px; page-break-after: avoid; font-size: 16pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">4.2&nbsp;</span><span style="font-family: 微软雅黑, sans-serif;">应用代码</span></h3><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span style="font-family: 微软雅黑, sans-serif;">运用前面学习过的知识，我们实现一个<span lang="EN-US">Listener</span>完成翻译工作。然后在<span lang="EN-US">main()</span>中构建起词法分析器和解析器，以及连接它们的数据流和语法树。</span></p><p align="center" style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: center; font-size: 10.5pt; font-family: Calibri, sans-serif;"><br /><img src="http://img.blog.csdn.net/20150430212739635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGNfNzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><br /></p><p align="center" style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: center; font-size: 10.5pt; font-family: Calibri, sans-serif;"><img src="http://img.blog.csdn.net/20150430212755094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGNfNzI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" /><img src="../../images/program/java/antlr/image019.png" style="cursor: default;" alt="" /></p><p style="orphans: 2; widows: 2; margin: 0cm 0cm 0.0001pt; text-align: justify; font-size: 10.5pt; font-family: Calibri, sans-serif;"><span lang="EN-US" style="font-family: 微软雅黑, sans-serif;">&nbsp;</span></p>