<p>单一职责原则(Single Responsibility Principle): 就是一个设计或实体应该只做一件事/只描述一个事物, 比如一个类Cat, 那么读代码的人应该觉得这个类始终都在说猫,而不是扯到狗身上去了, 虽然猫狗有时候会打架,但那也只是关联关系. 这与现实中也很相似, 如果你专著于一件事, 你会做得很出色. </p>
<p>开放封闭原则(Open-Close Principle): 一个实体应该对拓展开放,对修改封闭. 就是说, 任何一个系统, 需求总是在变的, 但是我们不能在任何需求到来的时候都把原有的设计推倒了重来, 而是尽可能的在保持相对稳定的情况下, 进行拓展. 事实上这也是世间万物的演变规律, 任何生物,都是从当初的单细胞生物随着环境的变化而逐渐演化过来的, 而不是说, 一旦环境变化, 则变异一个全新的形态出来. 在软件行业中, 这一原则体现在知识的积累, 系统的演化更新上. 优秀的平台(如java), 框架(如struts, spring), 都是由最初的雏形, 从版本0.1开始演化过来.</p>
<p>里氏替换原则(Liskov Substitution Principle): 子类必须能够替换掉他们的父类型. 这个原则考验的是继承结构的合理性, 如果子类不能完全取代父类的位置, 则继承结构就不合理.</p>
<p>依赖倒置原则(Dependency Inversion Principle): 设计应该依赖于抽象，而不能依赖于具体。也就是说要面向接口编程。 因为接口代表着功能，代表着规范，不易变。而实现却会随着时间和环境发生变化。比如银行，自从有银行开始，它就有存款和贷款业务， 那么存款和取款就是它的接口。但是不同的时代，具体的实现方式大有不同，以前都要到银行柜台上去办理， 后来有了支票， 现在有了电子帐户。如果我们有一个设计要使用银行的业务，不应该依赖于具体的某种实现方式，而应该依赖于接口。</p>
<p>接口隔离原则(Interface Seperation Principle): 使用多个专门的接口比使用单一的总接口要好. 系统对外提供宽窄不同的接口以应对不同的客户。</p>
