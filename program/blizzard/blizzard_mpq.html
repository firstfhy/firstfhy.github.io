<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>进军暴雪</title>
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	
	<link rel="stylesheet" href="../../stylesheets/stylesheet.css" media="screen">
	<link rel="stylesheet" href="../../stylesheets/pygment_trac.css"/>
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
	<script type="text/javascript" src="../../javascripts/script.js"></script>
	
	<meta name="description" content="firstfhy">
	
	<meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>
	<div class="wrapper">
		<div id="container">
		    <div id="main" role="main">
		    	<div class="download-bar">
			    	<div class="inner">
			          	<a class="code">BLIZZARD</a>
			        </div>
		        	<span class="blc"></span><span class="trc"></span>
		        </div>
		        <article class="markdown-body">
					<h3>
						进军暴雪
				   	</h3>
<div class="blog_details_20120222"><div>&nbsp;原文地址：<a href="http://www.campaigncreations.org/starcraft/inside_mopaq/" target="_blank"><span style="COLOR:#0556d0">http://www.campaigncreations.org/starcraft/inside_mopaq/</span></a> <br/><br/><span>第一章 关于MPQ的历史</span> <br/><br/><br/>MPQ，也称MoPaQ，是Mike O'Brien发明的一种压缩文件格式。 <br/>在1996作为，MPQ应用在Diablo（暗黑破坏神）游戏中。 <br/>然而它的版权属于 Blizzard 的父公司 Havas Interactive，并且在Mike O'Brien离开暴雪后继续使用。 正是MPQs由于在Diablo（暗黑破坏神）中的出色表现，使其继续应用在Starcraft（星际争霸）, Warcraft 2（魔兽争霸2）, Diablo 2（暗黑破坏神2）, Lords of Magic（魔法大帝）中。 <br/><br/><span>第二章 关于MPQ的介绍 <br/></span><br/><br/>MPQ内部包含了许多文件，包括坐标算法、声音、动画、字符串、数字数据和故事情节信息。 <br/>明显地，MPQ的潜力很大。要想利用MPQ，那么您就需要了解它。 <br/><br/>在有MPQ格式之前，一直使用的是WAR格式，在Warcraft 2，甚至在Warcraft1中存放游戏数据。然而WAR格式是简单的，不精制的，是由缺乏经验的程序员所编写的文件格式(相信我，我知道)。文件在档案中仅使用参考序数和是否被压缩做为唯一可选择调用的方法。 <br/>尽管如此它仍然完成了它的任务。它提供了压缩格式下的文件调用。但是，很快缺点开始出现。调用时使用参考序数，意味着一长传文件接口的名单必须被保留和被咨询，当程序员需要使用其中一个文件，那么则需要级长的时间，工作变得越来越繁琐。 <br/>当时这些问题并没有那么严重，所以有人坚持使用WAR格式，但是一切在使用Battle.net（网络对战）后，问题变得不能接受。 <br/><br/><br/>MPQ的特点 <br/>如被提及以前，MPQ格式一直被用做修正WAR的设计缺陷。但是现在他们也想增加一些全新的特点到MPQ。在暴雪的游戏中，MPQ格式的特点总结为以下几点： <br/><br/><span>Security. 安全</span> <br/><br/>暴雪一定不希望在游戏中玩家可以修改数据。或许他们提早知道MPQ格式可以为Starcraft使用。 不管怎样，安全是最重要的，由此他们显然做了级大的努力去维护游戏的安全性。 <br/><br/><span>Efficiency. 效率 <br/></span><br/>MPQs要求执行时先简单预先输入的各种各样的任务数据然后实时放出。对于预先输入数据，时间并不重要。 但是实时放出就是另一件事了，其中的数据必须快速地被解压使用。 <br/><br/><span>Multilinguality.多语言的计算机处理 <br/></span><br/>在最开始的时候，暴雪就计划发布其游戏在全球游戏市场，因此他们尽可能的做到多语言。 在创新时，他们决定设计多语种能写入MPQ格式。 <br/>。 <br/><span>Expandability.扩展 <br/></span><br/>显然的，在游戏中需要使用独立的数据。太大的数据不仅是效率低并且减慢游戏速度，如果补丁修改了，也是很麻烦的。暴雪明白这个道理，因而MPQ格式的要求就是有能力完全，高效率的，从多个档案数据中调用需要的数据。 <br/><br/><br/><span>什么是strom</span> <br/>相比在程序模块中复制函数，多数程序员喜欢把相同代码放到shared libraries（共享程序库）里。shared libraries是包含了任意程序功能的函数模块。不仅能避免多余，并且能缩小程序大小。 <br/>正因为如此，暴雪使用一个称为Storm的共享程序库(PC机上为Storm.dll，MAC机为Storm.bin)。 <br/>所有现代的暴雪游戏中都使用strom存放重要功能，比如读取MPQ，Battle.net和一些图形化例程。 <br/>当暴雪要发布新版本的游戏，只需要增加功能到strom，无需改变原有功能。 这意味着旧版本的游戏只用升级新版本strom就可以了，这就是我们俗称的安装补丁。 <br/>就像所有共享程序库，任何想使用它的程序都可以访问到它的函数。这就是为什么strom只包含MPQ读取功能。 <br/><br/><br/><span>什么是 MPQ API Library DLL</span> <br/><br/>虽然 Storm 没有包含任何编写MPQ的功能。 <br/>但是 StarEdit 包含，因为 SCM/SCX 文件也是 MoPaQ文件。 <br/>但是这些函数被加密了，所以只有知识渊博的黑客们才可以使用。 <br/>对于Blizzard 来说不幸的是，有一个这样的黑客，他的名字是 Andrey Lelikov(aka Lelik)。 <br/>他发现了一种访问这些宝贵的函数的途径，并把这个复杂的过程封装在 <br/>LMPQAPI.DLL（Lelik's MPQ API Library DLL）文件中。该文件自动破解 <br/>StarEdit，将这些函数展示在所有的程序员面前。<p><span>第三章 MPQ的基本原理 <br/></span><br/>通过整个计算机发展史来看，绝大多数的进步都是在求解问题中发生的。 <br/>那么在这一章中，我们将采取看看一些涉及到MPQ的问题及其解决办法。 <br/><br/><span><span>HASH (散列或哈希)</span> <br/></span><br/>问题：你有一个非常大的字符串数组，和一个字符串 <br/>怎么知道字符串是否在数组中？ <br/><br/>你可能会开始在数组中与其他字符串比较每个字符串，但是，当进行应用后，你会发现，这种方法在实际使用时是特别慢的。在此之前，你又怎能在没有与其他字符串比较的情况下，确定这个字符串是否存在？ <br/><br/>解决方法：hash <br/>hash是规模较小的数据类型（例如数字）能指向其他较大的数据类型（通常是字符串） 。在这种情况下，您可以在数组中先存储hash。然后再计算其他字符串的hash，并比较它存储的hash。通过字符串比较，如果hash在数组相匹配的新的hash，就可以核实存在。这就是所谓的索引查找，可以加快对于不同大小的数组和平均长度的字符串的搜索速度约100倍。 <br/><br/></p><table><tbody><tr><td colspan="3" width="97%"><span><span><em>unsigned long HashString(char *lpszString) <br/>{</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td colspan="2" width="91%"><span><span><em>unsigned long ulHash = 0xf1e2d3c4; <br/><br/>while (*lpszString != 0) <br/>{</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td width="85%"><span><span><em>ulHash &lt;&lt;= 1; <br/>ulHash += *lpszString++;</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td colspan="2" width="91%"><span><span><em>} <br/><br/>return ulHash;</em></span></span></td></tr><tr><td colspan="3" width="97%"><span><span><em>}</em></span></span></td></tr></tbody></table><p><br/>上面的代码，体现了一个很简单的散列算法。 <br/>功能是在每个字符添加前，把哈希值向左移动1bit，并总计字符串中的字符。 <br/>使用这种算法，字符串“arr\ units.dat ”将散列为0x5a858026，“unit\neutral\ acritter.grp ”将散列为0x694cd020 。 <br/>无可否认，这是一个很简单的算法，但是不是非常实用。因为在较低的数字范围内会产生一个相对可预见的输出，以及出现大量的冲突。当多于一个字符串散列为相同值就会出现冲突。 <br/>MPQ格式使用一个非常复杂的散列算法（如下所示），产生完全不可预测的哈希值，这个算法十分有效，这就是所谓的单向散列。 <br/>就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。从预映射，能够简单迅速的得到散列值，而在计算上不可能构造一个预映射，使其散列结果等于某个特定的散列值。 <br/>即构造相应的任意长度明文=固定长度散列值-1（固定长度散列值）不可行。 <br/>故此使用特别算法，文件名“arr\ units.dat ”将散列为0xf4e6c69d ，和“unit\neutral\ acritter.grp ”将散列为0xa26067f3 。 <br/><br/><em></em></p><table><tbody><tr><td colspan="3" width="100%"><span><span><em>unsigned long HashString(char *lpszFileName, unsigned long dwHashType) <br/>{</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td colspan="2" width="94%"><span><span><em>unsigned char *key = (unsigned char *)lpszFileName; <br/>unsigned long seed1 = 0x7FED7FED, seed2 = 0xEEEEEEEE; <br/>int ch; <br/><br/>while(*key != 0) <br/>{</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td width="88%"><span><span><em>ch = toupper(*key++); <br/><br/>seed1 = cryptTable[(dwHashType &lt;&lt; 8) + ch] ^ (seed1 + seed2); <br/>seed2 = ch + seed1 + seed2 + (seed2 &lt;&lt; 5) + 3;</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td colspan="2" width="94%"><span><span><em>} <br/>return seed1;</em></span></span></td></tr><tr><td colspan="3" width="100%"><span><span>}</span></span></td></tr></tbody></table><p><em></em><span>HASH TABLES(散列表或哈希表) <br/></span><br/>问题：您尝试在前面的示例中使用相同索引，您的程序一定会有中断现象发生，而且不够快。 <br/>您能做的只有让程序不去查询数组中的所有散列值。或者 您可以只做一次对比就可以得出在列表 中是否存在字符串。 <br/>听起来不错，真的么？ <br/>骗你的啦！！！ <br/><br/>解决方案：a hash table <br/><br/>哈希表是数组中的一种特殊类型，也就是设定指定字符串的偏移量为那个字符串的散列值。 <br/>我的意思是，假如您设置一个字符串列表，使用一个单独的固定大小的数组作为哈希表。 <br/>您想查看新的字符串是否在前面的哈希表里。 <br/>那么您需要先计算要查看字符串的散列值，然后以哈希表大小的散列值为模求余数。 <br/>因此，如果您使用上面列出的简单散列算法，"arr\units.dat"将散列为0x5A858026，使其偏移量 <br/>0x26(0x5A858026 divided by 0x400 is 0x16A160, with a remainder of 0x26)。 <br/>假如这个地方有字符串，那么就会与被添加的字符串比较。 <br/>假如字符串在0x26不匹配，或直接不存在，那说明该添加的字符并不在在数组中。 <br/>下面的代码说明了这： <br/><em></em></p><table><tbody><tr><td colspan="3" width="100%"><span><span><em>int GetHashTablePos(char *lpszString, SOMESTRUCTURE *lpTable, int nTableSize) <br/><br/>{</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td colspan="2" width="94%"><span><span><em>int nHash = HashString(lpszString), nHashPos = nHash % nTableSize; <br/><br/>if (lpTable[nHashPos].bExists &amp;&amp; !strcmp(lpTable[nHashPos].pString, lpszString))</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td width="88%"><span><em><span>return nHashPos</span><span>;</span></em></span></td></tr><tr><td width="6%">&nbsp;</td><td colspan="2" width="94%"><span><span><em>else</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td width="88%"><span><span><em>return -1; //Error value</em></span></span></td></tr><tr><td colspan="3" width="100%"><span><span><em>}</em></span></span></td></tr></tbody></table><p><em><span><span style="FONT-SIZE:x-small"><br/></span></span></em><br/>现在在这方面的解释有一个明显的缺陷。您认为发生冲突时（两个不同的字符串哈希以同等价值的） ？显然，他们不能在哈希表占用相同的接口。通常，解决的方法是在哈希表每个接口作为一个指针到一个链表，然后将链表里所有接口的散列值设置相同。 <br/>MPQ使用一个关于文件名称的哈希表记录内部文件，但是这个哈希表的格式与普通哈希表有所不同。 <br/>首先，MPQ根本不保存文件名，用三个散列值代替保存散列值的偏移量和为了核查文件名保存真实的文件名。 <br/>而是使用三个不同哈希值：一个做为哈希表的偏移量，两个是做为核查。 <br/>两个做为核查的哈希值被用来代替真实的文件名称。当然，也有可能两个不同文件名称的散列值相同， <br/>不过这种情况发生的可能性为平均1:18889465931478580854784 ，对于任何人来说这应该足够安全了。 <br/><br/><br/>另一种方法：不同于常规的执行情况的mpq哈希表。 <br/>代替使用每个接口的链接表。当冲突发生时，把接口移动动下一个序列，并且重复动作，直到找到空闲空间。 <br/>下面的代码是在MPQ设置读取的基本方法： <br/><em></em></p><table><tbody><tr><td colspan="4" width="100%"><span><span><em>int GetHashTablePos(char *lpszString, MPQHASHTABLE *lpTable, int nTableSize) <br/>{</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td colspan="3" width="94%"><span><span><em>const int HASH_OFFSET = 0, HASH_A = 1, HASH_B = 2; <br/>int nHash = HashString(lpszString, HASH_OFFSET), nHashA = HashString(lpszString, HASH_A), nHashB = HashString(lpszString, HASH_B), nHashStart = nHash % nTableSize, nHashPos = nHashStart; <br/><br/>while (lpTable[nHashPos].bExists) <br/>{</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td colspan="2" width="88%"><span><span><em>if (lpTable[nHashPos].nHashA == nHashA &amp;&amp; lpTable[nHashPos].nHashB == nHashB)</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td width="82%"><span><span><em>return nHashPos;</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td colspan="2" width="88%"><span><span><em>else</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td width="82%"><span><span><em>nHashPos = (nHashPos + 1) % nTableSize; <br/></em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td colspan="2" width="88%"><span><span><em>if (nHashPos == nHashStart)</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td width="82%"><span><span><em>break;</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td colspan="3" width="94%"><span><span><em>} <br/><br/>return -1; //Error value</em></span></span></td></tr><tr><td><span><span>}</span></span></td></tr></tbody></table><p><em></em>每条代码反复研究，理论的背后是不难的。 <br/>它基本上是如下这个过程： <br/><br/>1.计算3个散列值（一个冲突和两个检查）并将其存储在变量。 <br/>2.移动冲突散列值的接口 <br/>3.接口未使用的吗？如果是的话，停止搜寻，并传回'文件没有被发现' 。 <br/>4.两个检查是否匹配检查我们正在寻找文件的散列值呢？如果是的话，停止搜寻，并传回目前的接口。 <br/>5.如果在最后一个接口，移动到列表中的下一个接口，（wrapping around to the beginning ？？）。 <br/>6.刚移动的借口是否和冲突时的散列值相同（是否检查了整个哈希表？ ） ？如果是的话，停止搜寻，并传回'文件没有被发现' 。 <br/>7.回到第3步。 <br/>如果您很仔细的话，您可能会从我的解释和示例代码注意到，是因为mpq的哈希表已保留所有文件接口在MPQ 。那么您认为每一个哈希表项如何得到填补？答案可能出乎您的意料却显而易见：您不能继续添加文件。几个人都问我为什么有一个上限（所谓的档案限制），在一个MPQ中可以有多少档案， ，是否有任何的方式解决这个限制。那么，您已经有了第一个问题的答案。至于第二项;没有，您不能绕开该文件的限制。对这个问题，哈希表，甚至不能调整大小，除非您重新改造MPQ。在哈希表每个接口因为重新设置大小不同位置可能会改变。而且导致无法获得新的地址，因为地址是文件名的散列值，并且我们还可能不知道档案名称。 <br/><br/><br/><span>Compression 压缩</span> <br/>问题：您有一个很大的程序（比如说， 50 megs ） ，您要分发在互联网上。但50 megs是一个非常大的下载量，而且别人未必有兴趣等待四个半小时去下载这个程序。 <br/><br/>解决方法：压缩。 <br/>压缩是一门艺术。是在更小的内存中重新放置等量的数据。 <br/>有数以百计不同的压缩算法，使用不同的方式。 <br/>MPQ实际使用的算法是the Data Compression Library, licensed from PKWare (one of the leaders in applied compression)，在此解释太过于复杂。相反，我会尝试解释一个更简单的压缩算法的例子。 <br/><br/>本章节并不完全 ，因为作者没写完 <br/><br/><br/><span>Encryption 加密</span> <br/><br/>这个世界上总是有喜欢剽窃的人存在，所以我们需要有一个保护资料安全的系统。 <br/>千百年来人们一直试图传递信息给他人。从手写的信件进行，信使徒步穿越古希腊，纳粹潜艇的无线电传输，在第二次世界大战，使用信用卡交易，到网络应用的今天，有能力去确保别人无法获得您的信息是必要的。 <br/>所谓的加密是复杂的艺术的保护，然而我们不知道设计第一个算法的人，我们也不知道到底有多少的算法。一切从简单的数据加扰，嬗变，甚至算法，其中有解密密钥（有时也称为密码）是不同的加密密钥（在一个方法所谓非对称加密） ，已做了一次又一次。 <br/>做为一个全面的权威加密方法，本文章肯定从来没有索赔，也不期望。 <br/>您只需要知道加密是你与MPQ直接相关的。 <br/>让我们从一个简单的加密算法开始，这是刊登在《Basic Lab Notes》 （为了可读性本人改变了一些变数名称，评论删除） ： <br/><em></em></p><table><tbody><tr><td colspan="3" width="100%"><span><span><em>void EncryptBlock(void *lpvBlock, int nBlockLen, char *lpszPassword) <br/>{</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td colspan="2" width="94%"><span><span><em>int nPWLen = strlen(lpszPassword), nCount = 0; <br/>char *lpsPassBuff = (char *)_alloca(nPWLen); <br/><br/>memcpy(lpsPassBuff, lpszPassword, nPWLen); <br/><br/>for (int nChar = 0; nCount &lt; nBlockLen; nCount++) <br/>{</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td width="88%"><span><span><em>char cPW = lpsPassBuff[nCount]; <br/><br/>lpvBlock[nChar] ^= cPW; <br/><br/>lpsPassBuff[nCount] = cPW + 13; <br/><br/>nCount = (nCount + 1) % nPWLen;</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td colspan="2" width="94%"><span><span><em>} <br/><br/>return;</em></span></span></td></tr><tr><td colspan="3" width="100%"><span><span><em>}</em></span></span></td></tr></tbody></table><p><em><br/></em>这是非常简单的哈希代码，不应被用来在一个实际的程序中使用。 <br/>即使代码是隐藏的（没有双关语意），这也是简单的 。 <br/>不言而喻，这是通过块进行加密的，把每个字节与相应的字节的密码转换为二进制。然后修改字节的密码，加入13 （ 选择13是因为这是一个素数）。这样做是为了使代码的模式，更难以识别。 <br/>那么，用此算法，加密字符串“encryption” （ 65 6E 63 72 79 70 74 69 6F 6E），加密的密码“ mpq ” （4D 50 51 ），这样会得到一个无法读取字符串（28 3E 32 28 24 2E 13 03 04 1A）。 <br/>现在，这个算法是对称的。这意味着密码是用来加密有相同密码的块。事实上，由于转换为二进制是一个对称的运作，完全相同的算法可以用来解密。请注意，大多数的对称加密算法是不完全对称，所以他们要求加密和解密的功能有所不同。 <br/><br/>好吧，下面就就是关键的地方。 <br/>如果您想要编写，就必须在哪里都知道加密算法。 <br/>教导给您这个方法是我的使命。 <br/><br/>MPQ的加密算法混合其他加密技术。它创建了一个加密表（这也是用在散列函数） ，并使用一个文件的加密密钥，以挑选出某些成员的加密表。然后对表中的成员进行转换成二进制数据加密。现在，用一个相当奇怪的方法来做，所以或许有些代码将显示您it is overcomplicated :-p。以下代码生成密码表数组长度为0x500： <br/><em></em></p><table><tbody><tr><td colspan="4" width="100%"><span><span><em>void prepareCryptTable() <br/>{</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td colspan="3" width="94%"><span><span><em>unsigned long seed = 0x00100001, index1 = 0, index2 = 0, i; <br/><br/>for(index1 = 0; index1 &lt; 0x100; index1++) <br/>{</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td colspan="2" width="88%"><span><span><em>for(index2 = index1, i = 0; i &lt; 5; i++, index2 += 0x100) <br/>{</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td width="82%"><span><span><em>unsigned long temp1, temp2; <br/><br/>seed = (seed * 125 + 3) % 0x2AAAAB; <br/>temp1 = (seed &amp; 0xFFFF) &lt;&lt; 0x10; <br/><br/>seed = (seed * 125 + 3) % 0x2AAAAB; <br/>temp2 = (seed &amp; 0xFFFF); <br/><br/>cryptTable[index2] = (temp1 | temp2);</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td colspan="2" width="88%"><span><span><em>}</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td colspan="3" width="94%"><span><span><em>}</em></span></span></td></tr><tr><td colspan="4" width="100%"><span><span>}</span></span></td></tr></tbody></table><p><em></em><br/><em>你是不是越来越觉得暴雪聘请了一名心怀不满的微积分教授写这些算法？还好对与我这不是问题，如果你不明白此代码。如果您想要编写，您需要这些功能，你不一定要了解他们。无论如何，在密码表初始化后，我们可以解密MPQ数据，具有下列功能（不要期望我向您解释，我不想知道如何运作自己！ ） ： <br/></em><em></em></p><table><tbody><tr><td colspan="3" width="100%"><span><span><em>void DecryptBlock(void *block, long length, unsigned long key) <br/>{</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td colspan="2" width="94%"><span><span><em>unsigned long seed = 0xEEEEEEEE, unsigned long ch; <br/>unsigned long *castBlock = (unsigned long *)block; <br/><br/>// Round to longs <br/>length &gt;&gt;= 2; <br/><br/>while(length-- &gt; 0) <br/>{</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td width="6%">&nbsp;</td><td width="88%"><span><span><em>seed += stormBuffer[0x400 + (key &amp; 0xFF)]; <br/>ch = *castBlock ^ (key + seed); <br/><br/>key = ((~key &lt;&lt; 0x15) + 0x11111111) | (key &gt;&gt; 0x0B); <br/>seed = ch + seed + (seed &lt;&lt; 5) + 3; <br/>*castBlock++ = ch;</em></span></span></td></tr><tr><td width="6%">&nbsp;</td><td colspan="2" width="94%"><span><span><em>}</em></span></span></td></tr><tr><td colspan="3" width="100%"><p><span><span><em>}</em></span></span></p><p><span><span><em><br/></em></span></span></p><p><span><span><em><br/></em></span></span></p></td></tr></tbody></table><p>&nbsp;</p><p><span>第四章 STROM <br/></span><br/>称为STROM库函数，或者简称为STROM。 <br/>它是对于本身的运行系统，拥有庞大的功能库函数。甚至不需要Microsoft支持。 <br/>它本身包含了足够强大的功能，甚至不需要调用本地API函数。 <br/>事实上，STROM包含了所有暴雪编写的可以重复使用的功能。 <br/>但它也拥有一些操作系统特殊的要求 比如那些在GDI，DirectX,QuickDraw等等。 <br/>原因很简单，就是为了减轻从一个系统到另一个系统的接口问题。 <br/>毕竟，这就是为什么花成千上万的工作时间把数以千计的操作系统函数从Windows源调用Mac一样，为什么在不花时间去做调用，而去改写功能？ <br/><br/>根据STROM的多个版本，大约累计了275个实际有用的功能。 <br/>正如您看到的，没更新STROM时，仍然使用STROM库函数。同样，更新后依然是旧的STROM库函数， <br/>只是做了更新。这是为了保证游戏在不同版本的兼容性。 <br/>这些275个使用功能分为约20个功能集（通常在Windows环境下称为subsystems，在MAC环境下称为managers。 <br/>下面所示部分清单： <br/><span>Memory Subsystem -记忆体子系统</span>-例行的共同记忆功能，包括分配新的内存，释放分配内存，灌装记忆体，以及更多。STROM没有自己的内存管理，包括内置的错误检查和其他强大的功能。该子系统功能与在PC上与'mem'前缀相等。 <br/><br/><span>String Subsystem - 字符串子系统</span>-功能是使用字符串，如复制，合并，搜索等这些职能是大多数部分，相等于'str'的功能。 <br/><br/><span>File Subsystem - 文件子系统-</span>功能是存取文件系统。有能力读出（但不包括写入）无论是在磁盘上的可靠文件，还是mpq档案。撇开mpq读取的功能，其他功能都是高级系统功能运行方式。 <br/><br/><span>Network Subsystem -网络子系统</span>-功能是接入远端的电脑系统，通过使用IPX，调制解调器， TCP/IP和直接电缆。职能是与服务器或在游戏中玩家的通讯。使用高级系统特殊调用。 <br/><br/><span>Error Subsystem -错误子系统-</span> 功能是捕捉和处理错误。这些职能大部分没有与任何操作系统的等值。 <br/><br/><span>Registry Subsystem -登录子系统</span>- 功能是持久性储存数据到计算机中。使用注册表在Windows系统，或MACS系统上。 <br/><br/><span>Bitmap Subsystem -位图系统-</span>功能是位图文件装载和显示。使用系统特殊调用。 <br/><br/>目前为止，大约只记录了40种功能，因为我手边没有足够时间来做，认真来做的话大约需要几个月。 <br/>此外这里只只讨论MPQ。 <br/><br/><br/><br/><span>Using the Strom API 使用STROM API函数</span> <br/><br/>说明：其余的这一章是针对Windows平台的！ <br/><br/>正如我以前说过，STROM功能任何人都可使用它们。不过，暴雪并不希望如此。 <br/>我花了最近两天时间，总结出来：STROM使用一个非常邪恶的方法来对付我们这种想使用它的人。 <br/>我花了至少10个小时的努力，试图解除愚蠢的事，而我现在可以很骄傲的说我成功了，我会全力为您解释冗长而复杂的细节。 <br/>经过我和Mike O'Brien所谓的the Storm Interface Library（接口库）斗智斗勇。发现这是由一个头文件和导入库组成，所以我做了Storm booby-traps这个工具 。要记得DLLs 101 ，是包含被用来当程序编译连接程序DLL的导入表的导入库 。这意味着什么，就是所有您需要做的就是storm.lib （在STROM接口库）与模块连接在您的程序和＃include storm.h头文件。这真令我疯狂，我不得不让您可以轻松使用the Storm Interface Library。 <br/>现在，为了以后少点麻烦，让我们现在就看看STROM的功能。 <br/><br/><span>Opening an MPQ Archive- SFileOpenArchive <br/>打开MPQ存档函数—SFileOpenArchive</span> <br/><br/></p><table><tbody><tr><td width="5%">&nbsp;</td><td colspan="2" width="70%"><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>BOOL WINAPI SFileOpenArchive(LPCSTR </strong><span><em>lpFileName</em></span><strong>, DWORD </strong><span><em>dwMPQID</em></span><strong>, DWORD </strong><em><span>dwUnknown</span></em><strong>, HANDLE *</strong><span><em>lphMPQ</em></span></font></span><strong><span><font size="1">);<br/></font></span></strong></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">lpFileName</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] A pointer to <strong>NULL</strong> terminated string that holds the path of the MPQ to open. <strong>SFileOpenArchive</strong> will crash if this is <strong>NULL</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">dwMPQID</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] An ID value that is saved internally in Storm for the MPQ. What this parameter is used for is not clear at this time.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">dwUnknown</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">Unknown. Should always be <strong>NULL</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">lphMPQ</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[out] Pointer to a <strong>HANDLE</strong> variable that, upon successful completion, will hold the <strong>HANDLE</strong> of the MPQ. <strong>SFileOpenArchive</strong> will fail if this is <strong>NULL</strong>.</font></span></span></td></tr></tbody></table></td></tr></tbody></table><p><br/>在此之前，您可以先看一个MPQ文件，您必须先打开它。 <br/>为此每您必须使用SFileOpenArchive。它会打开一个存档，并给你一个HANDLE，您可以稍后调用SFileOpenFileEx和SFileCloseArchive 。 <br/>第一个参数，lpFileName，只不过是mpq公开的名称，绝不能为空。 <br/>第二个参数，dwMPQID 是将指派给mpq内部的ID。这并不改变mpq ，目前还不清楚为什么这样做。 <br/>第三个参数，dwUnknown，这是唯一我们认为没用的，但是不容忽视。 <br/>最后一个参数，lphMPQ，是一个HADLE的指针（您必须先声明）。 <br/>如果SFileOpenArchive成功完成，this HANDLE will be that of the MPQ。 <br/>如果SFileOpenArchive成功，其返回值将为零。 <br/>但是，有几种情况可能导致SFileOpenArchive失败。 <br/>如果它失败，将返回一个值是假的。在这种情况下，您可以调用GetLastError获得更进一步的信息，为什么失败。如果lpFileName是一个零长度字符串或phMPQ是Null ，GetLastError 将返回ERROR_INVALID_PARAMETER 。如果该文件lpFileName不存在， GetLastError 将返回 ERROR_FILE_NOT_FOUND。在一些非常罕见的情况下， GetLastError可能会返回其他一些潜错误值。 <br/><br/><br/><span>Closing an Archive - SFileCloseArchive <br/>关闭存档函数 - SFileCloseArchive</span> <br/><br/></p><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>BOOL WINAPI SFileCloseArchive(HANDLE </strong><em><span>hMPQ</span></em></font></span><strong><span><font size="1">);<br/></font></span></strong></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">hMPQ</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The <strong>HANDLE</strong> of the MPQ to close, which was acquired earlier with <strong>SFileOpenArchive</strong>. <strong>SFileCloseArchive</strong> will fail (or worse) if this is <strong>NULL</strong> or a <strong>HANDLE</strong> not obtained with <strong>SFileOpenArchive</strong>.</font></span></span></td></tr></tbody></table><p><br/>一旦您开启一个mpq存档，你必须记住它关闭时，您就大功告成了！<span style="COLOR:#6600cc"><span style="COLOR:#000000">SFileCloseArchive</span> </span>是SFileOpenArchive 的产物。 <br/>作为与SFileOpenArchive ，SFileCloseArchive返回一个非零值，那就是成功的 <br/>如果返回一个假值，那就失败了。 <br/>然而，在这种情况下，GetLastError不会提供任何有用的信息。 <br/>-所以你只能假设原因是hMPQ参数是无效的。 <br/><br/><span>Opening a File Inside an MPQ - SFileOpenFileEx <br/>打开MPQ内的文件函数 - SFileOpenFileEx</span> <br/><br/><br/></p><table><tbody><tr><td width="5%">&nbsp;</td><td colspan="2" width="70%"><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>BOOL WINAPI SFileOpenFileEx(HANDLE </strong><em><span>hMPQ</span></em><strong>, LPCSTR </strong><span><em>lpFileName</em></span><strong>, DWORD </strong><em><span>dw</span></em><span><em>SearchScope</em></span><strong>, HANDLE *</strong><em><span>lphFile</span></em></font></span><strong><span><font size="1">);<br/></font></span></strong></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">hMPQ</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The <strong>HANDLE</strong> of the MPQ previously opened with <strong>SFileOpenArchive</strong> that contains the file you want to open. <strong>SFileOpenFileEx</strong> will fail or crash if this is <strong>NULL</strong> or a <strong>HANDLE</strong> not obtained with <strong>SFileOpenArchive</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">lpFileName</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] A pointer to a <strong>NULL</strong> terminated string that holds name of the file within the MPQ to be opened. <strong>SFileOpenFileEx</strong> will crash if this is <strong>NULL</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">dwSearchScope</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] Specifies where to look for a file when opening a file on the hard drive. Must be <strong>NULL</strong> when working with MPQs.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">lphFile</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[out] A pointer to a <strong>HANDLE</strong> variable that, upon successful completion, will hold the <strong>HANDLE</strong> of the requested file. <strong>SFileOpenFileEx</strong> will fail if this is <strong>NULL</strong>.</font></span></span></td></tr></tbody></table></td></tr></tbody></table><p><br/>只是因为你用SFileOpenArchive并不意味着您就可以从它立即开始读取。请记住，MPQ只不过是包含其他文件的多档案文件。在您可以阅读任何一个mpq ，您必须打开一个（或多个）的MPQ内部档案。 SFileOpenFileEx就是让您使用这一任务的函数;它将打开在一个mpq所请求的文件并对其返回一个HANDLE。 <br/>再次， sfileopenfileex将返回一个非零值就成功，是假值的就失败，您可以调用getlasterror获得的原因。如果lpfilename是一个零长度字符串或lphfile是Null ， getlasterror将返回error_invalid_parameter 。如果该文件不存在于mpq ， getlasterror会报告error_file_not_found 。在一些罕见的情况下， getlasterror可能会报告error_file_invalid ，并就极为罕见的情况下，它可能会返回其他一些模糊的错误值。 <br/>重要注意事项：当您调用sfileclosearchive关闭mpq ，同样会关闭所有MPQ内部打开的文件，您获取到来自sfileopenfileex的HANDLEs成为无效。如果您调用sfilereadfile ， sfilegetfilesize ， sfilesetfilepointer ，或sfileclosefile，这些其中一个无效的HANDL，调用将失败，并且STROM甚至可能崩溃。 <br/><br/><span>Closing a File Inside an MPQ - SFileCloseFile <br/>关闭MPQ内的文件函数 - SFileCloseFile <br/><br/></span></p><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>BOOL WINAPI SFileCloseFile(HANDLE </strong><em><span>h</span></em><span><em>File</em></span></font></span><strong><span><font size="1">);<br/></font></span></strong></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">hFile</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The <strong>HANDLE</strong> of the file to close, which was acquired earlier with <strong>SFileOpenFileEx</strong>. <strong>SFileCloseFile</strong> will fail (or worse) if this is <strong>NULL</strong> or a <strong>HANDLE</strong> not obtained with <strong>SFileOpenFileEx</strong>.</font></span></span></td></tr></tbody></table><p>就像SFileCloseArchive is to SFileOpenArchive, SFileCloseFile is the natural compliment of SFileOpenFileEx, 用来关闭一个已经打开的文件. <br/>也想sfileclosearchive ， sfileclosefile将返回一个非零值说明成功的，假值的就失败， getlasterror将不提供帮助。所幸的是，多于sfileclosearchive ， sfileclosefile只在hFlie是NULL或一个无效的HANDLE。 <br/><br/><span>Reading from a File in an MPQ - SFileReadFile <br/>读取MPQ内文件函数 - SFileReadFile <br/></span></p><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>BOOL WINAPI SFileReadFile(HANDLE </strong><em><span>hFile</span></em><strong>, LPVOID </strong><em><span>lpBuffer</span></em><strong>, DWORD </strong><em><span>nNumberOfBytesToRead</span></em><strong>, LPDWORD </strong><span><em>lpNumberOfBytesRead</em></span><strong>, LPOVERLAPPED </strong><em>lpOverlapped</em></font></span><strong><span><font size="1">);<br/></font></span></strong></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">hFile</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The <strong>HANDLE</strong> of the file to read from, which was acquired earlier with <strong>SFileOpenFileEx</strong>. <strong>SFileReadFile</strong> will crash if this is <strong>NULL</strong> or a <strong>HANDLE</strong> not obtained with <strong>SFileOpenFileEx</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">lpBuffer</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[out] A pointer to a buffer in memory where <strong>SFileReadFile</strong> will place the data read from the file. This buffer must be at least as large as <em>nNumberOfBytesToRead</em>. <strong>SFileReadFile</strong> will fail if this is <strong>NULL</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">nNumberOfBytesToRead</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The number of bytes for <strong>SFileReadFile</strong> to read from the file. <strong>SFileReadFile</strong> may crash if this is larger than the size of <em>lpBuffer</em>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">lpNumberOfBytesRead</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[out] A pointer to a <strong>DWORD</strong> that will hold the number of bytes actually read from the file. The number of bytes read will never be more than <em>nNumberOfBytesToRead</em>, but may be less if the number of unread bytes in the file is less than <em>nNumberOfBytesToRead</em>. It is not recommended to let this be <strong>NULL</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">lpOverlapped</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] A pointer to an <strong>OVERLAPPED</strong> structure. This is used for asynchronous reading of files on a disk, and must be <strong>NULL</strong> when reading files in MPQs.</font></span></span></td></tr></tbody></table><p><br/>当然，您要先打开再读取文件。 <br/>一旦你获得一个有效的文件HANDLE从sfileopenfileex ，这就是这个函数的功能。 sfilereadfile会读取指定的字节数，然后推进文件指针。这意味着，如果您有一个文件，您调用sfilereadfile会读取的一半的档案，当您再次调用sfilereadfile，你会得到另一半的档案。如果您需要再次读取上半部分的文件，你会需要调用sfilesetfilepointer 。 <br/>sfilereadfile将提供一个非零的返回值就成功，或虚假的就失败。不过，你必须记住，只是因为它返回一个非零值，并不等于它实际上读取了什么，这只是说明没有错误发生。 <br/>如果在该文件hfile有不足未读字节（字节从文件指针到文件结束）比要求数量少， sfilereadfile会读不到的数目要求字节; <br/>如果档案hfile的文件指针是在该文件的末尾， sfilereadfile会读什么，设置lpnumberofbytesread为0 ，返回真。因此，检查lpnumberofbytesread 是非常重要的。 <br/><br/><span>Getting a File's Size - SFileGetFileSize <br/>获得文件大小函数- SFileGetFileSize <br/></span></p><table><tbody><tr><td width="5%">&nbsp;</td><td colspan="2" width="70%"><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>DWORD WINAPI SFileGetFileSize(HANDLE </strong><em><span>h</span></em><span><em>File</em></span></font></span><strong><span><font size="1">, LPDWORD lpFileSizeHigh);<br/></font></span></strong></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">hFile</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The <strong>HANDLE</strong> of the file whose size is to be determined. <strong>SFileGetFileSize</strong> will crash if this is <strong>NULL</strong> or a <strong>HANDLE</strong> not obtained with <strong>SFileOpenFileEx</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">lpdwFileSizeHigh</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[out] A pointer to a <strong>DWORD</strong> that, upon successful completion, will hold the high 32-bits (a <strong>DWORD</strong>) of the file's size. However, it is not possible for a file in an MPQ to be this large (over 4 gigabytes), so this is virtually unused, and may safely be <strong>NULL</strong>.</font></span></span></td></tr></tbody></table></td></tr></tbody></table><p><br/>这是普遍认为是最坏的编程实践，因为完全可以进行修改，在开始读取时让不明长度的文件不会造成崩溃。sfilegetfilesize在这里只是把戏，因为它在用sfileopenfileex打开文件后才可以撷取文件的大小 。 <br/>也有一些重大的故障点在sfilegetfilesize 。首先是含糊不清错误。当sfilegetfilesize成功，它将返回文件的大小（可0 ！ ） 。但是，当发生错误时，它将返回0xFFFFFFFF的，而且同一件事，它会返回为4294967295字节（ 4 GB的） 。所幸的是，这不是一个很大的问题，正如您可能从未真正看到一个文件这么大。第二个问题，更危险的是sfilegetfilesize缺乏错误检查。 sfilegetfilesize不检查是否hfile是有效或是否为零。这意味着，如果你给它一个hfile的无效的HANDLE ，程序崩溃，电脑也会崩溃。因此，底线是这样的：无比谨慎使用此功能。 <br/><br/><br/><span>Moving the File Pointer - SFileSetFilePointer <br/>移动文件指针函数- SFileSetFilePointer <br/></span></p><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>DWORD WINAPI SFileSetFilePointer(HANDLE </strong><em><span>h</span></em><span><em>File</em></span><strong>, long </strong><em><span>nDistanceToMove</span></em><strong>, long *</strong><span><em>lpDistanceToMoveHigh</em></span><strong>, DWORD </strong><em><span>dwMoveMethod</span></em></font></span><strong><span><font size="1">);<br/></font></span></strong></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">hFile</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The <strong>HANDLE</strong> of the file whose file pointer is to be moved. <strong>SFileSetFilePointer</strong> will crash if this is <strong>NULL</strong> or a <strong>HANDLE</strong> not obtained with <strong>SFileOpenFileEx</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">nDistanceToMove</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The low-order 32-bits of the number of bytes for <strong>SFileSetFilePointer</strong> to move the file pointer, with positive numbers moving the pointer forward and negative numbers moving the pointer backward. This value can also be 0.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">lpDistanceToMoveHigh</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] A pointer to the high-order 32-bits of the distance for <strong>SFileSetFilePointer</strong> to move the file pointer. But, because MPQs do not support files this large, this is unused and <strong>must</strong> be <strong>NULL</strong> or <strong>SFileSetFilePointer</strong> will fail.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">dwMoveMethod</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] Specifies the relative location the file pointer will be moved to. Must be one of these following values in <strong>Windows.h</strong>:<br/><img border="0" jquery17025206673194826395="1" src="http://imgcache.qq.com/ac/qzone_v5/app/photo/sysbussy.jpg"/></font></span></span> <table><tbody><tr><td><span><span style="FONT-SIZE:x-small"><strong><font size="1">FILE_BEGIN</font></strong></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">The file pointer will be set to <em>nDistanceToMove</em> bytes from the beginning of the file. <em>nDistanceToMove</em> must be positive.</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><strong><font size="1">FILE_CURRENT</font></strong></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">The file pointer will be set to <em>nDistanceToMove</em> bytes from the current location of the file pointer.</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><strong><font size="1">FILE_END</font></strong></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">The file pointer will be set to <em>nDistanceToMove</em> bytes from the end of the file. <em>nDistanceToMove</em> must be negative.</font></span></span></td></tr></tbody></table></td></tr></tbody></table><p><br/>要想从文件任意位置读取，就要先在该文件提出移动指针，这个功能函数就是sfilesetfilepointer。 <br/>文件指针指向了下次读取时的读取位置。每次读取和编写将会移动文件指针到读写区域的最底部。 <br/><br/>sfilesetfilepointer实际上并不移动文件指针，只是在文件中对应ndistancetomove。相反， sfilesetfilepointer移动文件指针到一个相对位置，无论是开头或结尾的文件。 <br/>举例来说，假设您有一个千字节的文件。当文件第一次打开，它的文件指针设置为0 ，则指的是第一个字节。然后，您读100个字节从该文件。然后，您调用sfilesetfilepointer设置ndistancetomove 500 。如果您调用dwmovemethod 设置为file_begin，文件指针将被设定为500 。如果你曾dwmovemethod作为file_current ，文件指针将是600 ，因为文件指针被转移到了当您从档案读取后100字节。但如果设置dwmovemethod以file_end ， sfilesetfilepointer会失败，因为它将尝试设置档案指针一千四百九十九（文件中的最后字节， 999 ，加500 ）不存在。如果您多用几次，会发现这是个非常简单的函数。 <br/><br/>假如失败， sfilesetfilepointer返回0xFFFFFFFF ，作为sfilegetfilesize也有同样的陷阱 。但是，当圆满完成， sfilesetfilepointer会返回档案hfile新的绝对位置的文件指针 。这意味着您可以简单地获取当前的立场文件指针调用sfilesetfilepointer设置ndistancetomove 0 ， dwmovemethod设置为file_current 。事实上，这是为什么说不存在sfilegetfileposition功能。 <br/><br/>就像sfilegetfilesize ， sfilesetfilepointer会肆无忌惮地使用任何你给它hfile的HANDLE，不会进行任何错误检查。这意味着，确保获得一个有效的文件处理，您必须谨慎，否则，您的电脑又会崩溃。 <br/><br/><br/><span>Choosing a Language - SFileSetLocale <br/>选择语言- SFileSetLocale</span> <br/><br/></p><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>LCID WINAPI SFileSetLocale(LCID </strong><span><em>lcNewLocale</em></span></font></span><strong><span><font size="1">);<br/></font></span></strong></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">lcNewLocale</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The language code (<strong>LCID</strong>) that <strong>SFileSetLocale</strong> will make the new default. The following codes are ones that I've found in Starcraft MPQs:</font></span></span> <table><tbody><tr><td><span><span style="FONT-SIZE:x-small"><font size="1">0</font></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">Language Neutral/English</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><font size="1">0x407</font></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">German</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><font size="1">0x409</font></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">English</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><font size="1">0x40a</font></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">Spanish</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><font size="1">0x40c</font></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">French</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><font size="1">0x410</font></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">Italian</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><font size="1">0x416</font></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">Portuguese</font></span></span></td></tr></tbody></table></td></tr></tbody></table><p>SFileSetLocale 是功能简单，背后复杂的代表.它使用了暴雪的multilinguality系统。感谢它,一个单一的函数调用，保证所有文件读出一个mpq的语言。它的唯一参数是the entire Storm MPQ subsystem。它绝不会失败，并且它传回的语言代码你给它，不过其返回值毫无价值。 <br/><br/>multilinguality系统原理是这样的：每个MPQ档案有一个语言代码，并只要他们有不同的语言代码就可以有多个文件具有相同名称的。当调用sfileopenfileex时， sfileopenfileex寻找一个文件具有相同的语言代码储存，然后调用sfilesetlocale （如果sfilesetlocale从来没有被调用，语言的代码为0 ） 。如果一个文件匹配的语言代码无法找到， sfileopenfileex将打开中立语言（有一个语言代码0 ）版本的文件。 </p><table><tbody><tr><td><div><span>第五章 <br/>THE STARCRAFT CAMPAIGN EDITOR AND THE MPQ API LIBRARY <br/>星际争霸编辑器和MPQ API LIBRARY <br/></span><br/>Starcraft Campaign Editor 是什么呢？其实就是一个能让您自己作出星际争霸地图的程序。 <br/>并把地图以SCM格式保存，或者保存为SCX文件。 <br/>可是这些个SCM/SCXs文件 和Warcraft 2是一样的原始文件？ <br/>假如您用hex editor 看过这些文件，那么您会得到一个否定的答案。 <br/>实际上SCM/SCXs就是MPQ文件！！ <br/>那么你也许认为很简单，那你就错了，StarEdit使用了一套难以捉摸的MPQ编写套路。 <br/>不过在您仔细阅读下面的内容，您将会得到答案。 <br/><span><span>Using StarEdit - The MPQ API Library <br/>使用编辑器- The MPQ API Library</span> <br/></span><br/>注意：这章是针对WINDOWS平台的，适用于THE MPQ API LIBRARY 2.0或更高！ <br/><br/><br/>在这里我们并不能很快的编译，因为编辑器有的功能我们并不能直接使用。 <br/>不像STROM之类的shared libraries ，StarEdit拥有复杂的操作系统保护机智，而不只是对于文件的保护。就算您是一位很好的程序员，您一样无法直接修改它。对于这种高难度的熟练的对运行系统的改写，还没有人能完成过。 就在这个时候Andrey Lelikov （简称Lelik）横空出世。 <br/><br/>Lelik是一位熟悉系统内部工作机制的俄罗斯程序员。他设计了一个能够使用 StarEdit MPQ 的方法。 <br/>他把自己写的详细功能放进了MPQ API Library 。 <br/><br/>就像STROM，MPQ API Library（又名LMPQAPI），它包含了共享库（可惜的是，像STROM接口库，现在在MAC机上还没有）。LMPQAPI不仅包括了StarEdit的MPQ编写功能，而且提供接口读写STROM。 <br/>如果您想同时使用STROM和StarEdit，您不需要同时使用LMPQAPI和STROM接口库。 <br/>一个LMPQAPI足已。 <br/><br/>好吧。我提醒您一件事，您想在使用LMPQAPI的时候区分是用STROM还是StarEdit么？ <br/>STROM功能有就像使用STROM接口库时一样有一个前缀'SFile'，在使用StarEdit时，前缀是'Mpq'。 <br/>这是很重要的，因为这说明了STROM和StarEdit的功能不兼容。 <br/>这意味着您无法用SFileOpenArchive获得的MPQ HANDLE去在StarEdit（'Mpq'前缀的函数）里调用，反之亦然。 如果您还是调用的话，调用会失败，程序会崩溃。记住这点。 <br/><br/><span>&#191;Sé Habla Espa&#241;ol? <br/>让人讲西班牙语？</span> <br/><br/>因为75%以上的星际争霸或暗黑的玩家是以英语为母语，所以大多数MPQ开发测试都基于这些游戏的英文版。对于使用英文版游戏的玩家，MPQ会运行良好。但事实上，98%的标准MPQ文件使用的是language-neutral （比如图象文件等等）。甚至有人用全非英语的MPQ玩游戏也没有问题。 <br/>不过，很明显这里是有问题的，只是还要等些时间才有人能发现吧。 <br/><br/><br/>做为上面两章的解释，MPQ格式具有强大的多国语言功能。 <br/>但是，您完全没必要做多语言的SCM/SCXs。 <br/>这就是说，您完全不必要让StarEdit支持多语言功能，就连暴雪的程序员都懒的做。 <br/>但是我们都有兴趣研究MPQ，除非没必要，其中的许多语言功能还是有用的。 <br/><br/>在技术方面说，所有的StarEdit功能都只运行有语言代码为0或language-neutral代码的文件。 <br/>也就是说，MpqAddFileToArchive和MpqAddWAVToArchive只增加language- neutral files, MpqDeleteFile只删除language-neutral files, MpqRenameFile 只会重命名language-neutral files. <br/><br/>这种设计决定了，执行结果并不明显。在前一章也提到过，假如在打开有相同名称不同语言的文件时，STROM使用了SFileSetLocale做为语言过滤器，用来决定到底打开哪个文件。 <br/>假设在StarEdit使用一个MPQ文件代替patch_rt.mpq ，而且在那个MPQ文件里有英语/language-neutral解析度文件rez\gluAll.tbl （这文件内有多个语言版本），但是不能有葡萄牙语版本（选定任意语言）。 <br/>当您运行这个游戏的葡萄牙语版时，程序会查询在您MPQ文件中的该语言版。结果就是失败，而且默认又为英语版本的，对不对？ <br/>好吧，不是这样的。STROM允许您同时打开几个MPQ文件，并且STROM会搜索已经加载的MPQ，然后自动加载最新的MPQ到文件里。但是在这个过程中，STROM在系统为language-neutral以前，会检查已经打开的所有特殊语言的MPQ。 <br/>这意味着，前面STROM从broodat.mpq 载入葡萄牙语版本，而不是您自己的language-neutral 版本。 <br/>很不幸，现在还没有解决的办法，希望新版本的LMPQAPI能被解决吧。 <br/><br/><br/><br/><span>Initializing the MPQ API Library - MpqInitialize <br/>初始化MPQ API Library函数- MpqInitialize <br/></span><br/><em>BOOL WINAPI MpqInitialize();</em> <br/><br/>不像STROM，LMPQAPI在控制StarEdit时有巨大的复杂的任务要做。 <br/>因此，无法在启动LMPQAPI时做完一切。你必须告诉LMPQAPI什么时候运行。所幸，这很简单。 <br/>你要做的就是在您启动程序前调用MpqInitialize，LMPQAPI会自动做完剩下的。 <br/>请确定在调用LMPQAPI其他函数前，您调用了MpqInitialize。此外，即使您对STROM接口库什么都不做，也必须在任何STROM函数调用前被调用。 <br/>一次调用会同时初始化STROM和STAREIDT。 <br/><br/>1.Starcraft/Brood War 1.07 必须已经安装，Storm.dll和StarEdit.exe必须在程序目录中 <br/>2.StarEdit不能和LMPQAPI一起运行. <br/><br/>为了调用MpqInitialize初始化上面的两个要求必须满足。尽管还有其他原因，上面两个却是最常见的。 <br/>不管什么原因，MpqInitialize调用失败后，都会返回FLASH，您可以检索GetLastError设置一个错误值。 <br/>如果LMPQAPI无法在游戏目录或在您程序的目录里无法找到StarEdit.exe ，那么GetLastError会返回MPQ_ERROR_NO_STAREDIT； <br/>如果StarEdit.exe的版本不匹配，GetLastError会返回MPQ_ERROR_BAD_STAREDIT； <br/>如果StarEdit已经运行GetLastError会返回MPQ_ERROR_STAREDIT_RUNNING； <br/>如果是因为其他原因GetLastError通常会返回MPQ_ERROR_INIT_FAILED。 <br/><br/>但是，无论为什么GetLastError调用失败，返回了什么，您要做的就是尽快的关闭程序。 <br/>不要调用任何LMPQAPI功能（STROM或者StarEdit的功能），当然也不要在调用MpqInitialize了。 <br/><br/><br/><span>Opening an MPQ for Editing - MpqOpenArchiveForUpdate <br/>打开MPQ- MpqOpenArchiveForUpdate <br/></span><br/><table><tbody><tr><td colspan="4" width="100%"><span><font size="1"><span style="FONT-SIZE:x-small"><strong>HANDLE WINAPI MpqOpenArchiveForUpdate(LPCSTR </strong><span><em>lpFileName</em></span><strong>, DWORD </strong></span><em><span><span style="FONT-SIZE:x-small">dwCreationDisposition</span></span></em></font></span><span style="FONT-SIZE:x-small"><span><font size="1"><strong>, DWORD </strong><em><span>dwHashTableSize</span></em></font></span><strong><span><font size="1">);<br/></font></span></strong></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">lpFileName</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] A pointer to <strong>NULL</strong>-terminated string that holds the path of the MPQ to open. <strong>MpqOpenArchiveForUpdate</strong> will fail if this is <strong>NULL</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">dwCreationDisposition</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] Specifies what <strong>MpqOpenArchiveForUpdate</strong> should do with the archive if it does/doesn't exist. Must be one of the following values defined in lmpqapi.h:</font></span></span> <table><tbody><tr><td><strong><span><span style="FONT-SIZE:x-small"><font size="1">MOAU_CREATE_NEW</font></span></span></strong></td><td><span><span style="FONT-SIZE:x-small"><font size="1"><strong>MpqOpenArchiveForUpdate</strong> will create a brand new archive. If <em>lpFileName</em> already exists, <strong>MpqOpenArchiveForUpdate</strong> will fail.</font></span></span></td></tr><tr><td><strong><span><span style="FONT-SIZE:x-small"><font size="1">MOAU_CREATE_ALWAYS</font></span></span></strong></td><td><span><span style="FONT-SIZE:x-small"><font size="1"><strong>MpqOpenArchiveForUpdate</strong> will create a new archive if <em>lpFileName</em> doesn't exist. If <em>lpFileName</em> does exist, it will be deleted and overwritten.</font></span></span></td></tr><tr><td><strong><span><span style="FONT-SIZE:x-small"><font size="1">MOAU_OPEN_EXISTING</font></span></span></strong></td><td><span><span style="FONT-SIZE:x-small"><font size="1"><strong>MpqOpenArchiveForUpdate</strong> will open the archive <em>lpFileName</em>. <strong>MpqOpenArchiveForUpdate</strong> will fail if <em>lpFileName</em> does not exist.</font></span></span></td></tr><tr><td><strong><span><span style="FONT-SIZE:x-small"><font size="1">MOAU_OPEN_ALWAYS</font></span></span></strong></td><td><span><span style="FONT-SIZE:x-small"><font size="1">If <em>lpFileName</em> exists, <strong>MpqOpenArchiveForUpdate</strong> will open it. If it doesn't, <strong>MpqOpenArchiveForUpdate</strong> will create a new archive.</font></span></span></td></tr><tr><td><strong><span><span style="FONT-SIZE:x-small"><font size="1">MOAU_MAINTAIN_LISTFILE</font></span></span></strong></td><td><span><span style="FONT-SIZE:x-small"><font size="1">This flag specifies that as <strong>MpqOpenArchiveForUpdate</strong> uses the archive <em>lpFileName</em>, it should update the internal listfile, if one exists. This is a flag, and must be ORed (with the | operator) with one of the other options for <em>dwCreationDisposition</em></font></span></span></td></tr></tbody></table></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">dwHashTableSize</font></em></span></span></td><td><font size="1"><span><span style="FONT-SIZE:x-small">[in] Whenever <strong>MpqOpenArchiveForUpdate</strong> creates a new archive (see the <em>dwCreationDisposition</em> </span></span><span><span style="FONT-SIZE:x-small">for details on when this occurs), </span></span><span><span style="FONT-SIZE:x-small"><em>dwHashTableSize</em></span></span><span><span style="FONT-SIZE:x-small"> specifies how large the hash table for the new archive will be, with a minimum size of 16, and a maximum size of 262,144 (if </span></span><span><span style="FONT-SIZE:x-small"><em>dwHashTableSize</em></span></span><span><span style="FONT-SIZE:x-small"> is not within these values, </span></span><span><span style="FONT-SIZE:x-small"><strong>MpqOpenArchiveForUpdate</strong> </span></span><span><span style="FONT-SIZE:x-small">will change it). This parameter does <em>not</em> affect archives that already exist.</span></span></font></td></tr></tbody></table><br/>与STROM一样,您在使用前必须先打开它. <br/>MpqOpenArchiveForUpdate 打开(或创建)一个存档,这是为了您使用其他StarEdit功能的,并返回存档的HANDLE. <br/><br/>但是不像SFileOpenArchive,MpqOpenArchiveForUpdate需要您在时间上做出选择. <br/>第一选择是dwcreationdisposition参数。它告诉mpqopenarchiveforupdate是否应该创建一个新的存档还是打开一个现有的，或两者之间。其他的决定性参数是dwhashtablesize 。 dwhashtablesize告诉mpqopenarchiveforupdate创建什么大小存档的哈希表（这也是该文件限制），在 <br/>mpqopenarchiveforupdate事件中必须创建要一个新的存档。 <br/>做为一个存档的哈希表大小差不多是1000，除非你知道存档一定会超过1000个文件。 <br/>但同时请记住，每个哈希表项和存档文件将新增16个字节，（见第2章的哈希表，或第5章关于mpq哈希表的更多信息） 。 <br/><br/><br/>在上面的进程中MpqOpenArchiveForUpdate可能调用失败. <br/>MpqOpenArchiveForUpdate将返回INVALID_HANDLE_VALUE或者NULL. <br/>我们根据调用GetLastError通常可以获取有用的信息,但不是绝对. <br/>如果lpfilename参数为空， getlasterror将返回error_invalid_parameter 。 <br/>如果dwcreationdisposition返回moau_open_existing或者lpfilename不存在， getlasterror将返回error_file_not_found 。反过来说，如果dwcreationdisposition返回moau_create_new和档案lpfilename已经存在， getlasterror将返回error_already_exists 。 <br/>最后，如果mpq存档存在，但是是无效或损坏的， getlasterror将返回mpq_error_mpq_invalid 。 <br/>在一些罕见的情况下， getlasterror将返回其他一些错误代码。 <br/><br/><span>Closing a Modified Archive - MpqCloseUpdatedArchive <br/>关闭修改过的存档- MpqCloseUpdatedArchive</span> <br/><br/><table><tbody><tr><td>&nbsp;</td><td colspan="2"><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>BOOL WINAPI MpqCloseUpdatedArchive(HANDLE </strong><em><span>hMPQ</span></em><strong>, DWORD </strong><em><span>dwUnknown</span></em></font></span><strong><span><font size="1">);<br/></font></span></strong></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">hMPQ</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The <strong>HANDLE</strong> of the MPQ to close, which was acquired earlier with <strong>MpqOpenArchiveForUpdate</strong>. <strong>MpqCloseUpdatedArchive</strong> will fail (or worse) if this is <strong>NULL</strong> or a <strong>HANDLE</strong> not obtained with <strong>MpqOpenArchiveForUpdate</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">dwUnknown</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">Unknown. Should always be <strong>NULL</strong>.</font></span></span></td></tr></tbody></table></td></tr></tbody></table><br/>这里和在STROM中一样,您在哪用SFileOpenArchive打开MPQ,那么就在修改它的地方用SFileCloseArchive 关闭. <br/>那么MPQ存档打开时用MpqOpenArchiveForUpdate,关闭时用MpqCloseUpdatedArchive. <br/>然而在这时候有一点区别.STROM不会修改实际MPQ,所以关闭MPQ HANDLE时没有什么特别需要做的. <br/>但是StarEdit 确实修改了MPQ.而且MPQ的散列值和文件表是在没有调用MpqCloseUpdatedArchive关闭MPQ HANDLE前不能写在MPQ分区的. <br/>这意味着要快速关闭StarEdit MPQ HANDLEs,要不然您有可能再次程序崩溃,而无法保存修改的MPQ. <br/><br/><br/><span>Adding a File - MpqAddFileToArchive <br/>添加文件函数- MpqAddFileToArchive</span> <br/><br/><table><tbody><tr><td>&nbsp;</td><td colspan="2"><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>BOOL WINAPI MpqAddFileToArchive(HANDLE </strong><em><span>hMPQ</span></em><strong>, LPCSTR </strong><span><em>lpSourceFileName</em></span><strong>, LPCSTR </strong><span><em>lpDestFileName</em></span><strong>, DWORD </strong><span><em>dwFlags</em></span><strong>);</strong></font></span></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">hMPQ</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The <strong>HANDLE</strong> of the MPQ to add the file to, which was acquired earlier with <strong>MpqOpenArchiveForUpdate</strong>. <strong>MpqAddFileToArchive</strong> will fail if this is <strong>NULL</strong> or a <strong>HANDLE</strong> not obtained with <strong>MpqOpenArchiveForUpdate</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">lpSourceFileName</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] A pointer to a <strong>NULL</strong>-terminated string containing the path of the file on disk to add. <strong>MpqAddFileToArchive</strong> will crash if this is <strong>NULL</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">lpDestFileName</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] A pointer to a <strong>NULL</strong>-terminated string containing the name that the file will be given in the MPQ. <strong>MpqAddFileToArchive</strong> will crash if this is <strong>NULL</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">dwFlags</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] Flags specifying properties that <strong>MpqAddFileToArchive</strong> will apply to the file inside the MPQ. Must be a combination of the following flags specified in lmpqapi.h:</font></span></span> <table><tbody><tr><td><strong><span><span style="FONT-SIZE:x-small"><font size="1">MAFA_ENCRYPT</font></span></span></strong></td><td><span><span style="FONT-SIZE:x-small"><font size="1">The file will be encrypted.</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><strong><font size="1">MAFA_COMPRESS</font></strong></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">The file will be compressed.</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><strong><font size="1">MAFA_REPLACE_EXISTING</font></strong></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">If the file <em>lpDestFileName</em> already exists in the MPQ, it will be replaced with the new file to be added</font></span></span></td></tr></tbody></table></td></tr></tbody></table></td></tr></tbody></table><br/>往往大约 95%的时候会在使用 StarEdit MPQ功能时候添加文件. 对于这个任务, 您会用到的函数有MpqAddFileToArchive和它的姊妹功能MpqAddWAVToArchive (稍后讨论). <br/>MpqAddFileToArchive在MPQ hMPQ分区添加文件lpSourceFileName 使用名称lpDestFileName, 并在这个过程中压缩 或/和 加密它. <br/><br/>由于一些设计上的疏漏,在您并没有完全明白前,MpqAddFileToArchive会是个大麻烦. <br/>1.MpqAddFileToArchive并不检查lpSourceFileName和lpDestFileName是否为空. <br/>就是说假如任一参数为空,您会再次看到程序崩溃. <br/>2.覆盖MPQ中已有文件时MpqAddFileToArchive的运行机制. <br/>当您调用MpqAddFileToArchive去添加的文件已经存在MPQ中（在这种情况下，你就不得不指定dwflags为mafa_replace_existing ）,MpqAddFileToArchive会在不确定文件lpSourceFileName是否存在前就不分青红皂白地删除存在的文件lpDestFileName. <br/>解决的办法很简单:确保lpsourcefilename和lpdestfilename是有效的（非空） ，以及确保lpsourcefilename存在之前，调用mpqaddfiletoarchive 。 <br/><br/>现在您应该可以饶过所有的障碍,用mpqaddfiletoarchive成功添加文件了吧. <br/>这时mpqaddfiletoarchive将允许返回TURE. <br/>如果有错误，它将返回FALSE 。在这种情况下，少量的信息可调用getlasterror 。 <br/>如果该文件lpsourcefilename不存在， getlasterror将返回error_file_not_found （尽管它的有点晚） 如果哈希表是FULL（见第2章） ， getlasterror将返回mpq_error_hash_table_full 。 <br/>如果该文件lpdestfilename已经存在 和在dwflags中未指定mafa_replace_existing ， getlasterror将返回mpq_error_already_exists 。 <br/>但是，在很多情况下getlasterror将返回其他一些错误代码或没有代码。 <br/><br/><br/><br/><span>Adding a File with WAV Compression - MpqAddWAVToArchive <br/>添加WAV压缩文件函数- MpqAddWAVToArchive</span> <br/><br/><table><tbody><tr><td>&nbsp;</td><td colspan="2"><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>BOOL WINAPI MpqAddWAVToArchive(HANDLE </strong><em><span>hMPQ</span></em><strong>, LPCSTR </strong><span><em>lpSourceFileName</em></span><strong>, LPCSTR </strong><span><em>lpDestFileName</em></span><strong>, DWORD </strong><span><em>dwFlags</em></span><strong>, DWORD </strong><span><em>dwQuality</em></span><strong>);</strong></font></span></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">hMPQ</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The <strong>HANDLE</strong> of the MPQ to add the file to, which was acquired earlier with <strong>MpqOpenArchiveForUpdate</strong>. <strong>MpqAddWAVToArchive</strong> will fail if this is <strong>NULL</strong> or a <strong>HANDLE</strong> not obtained with <strong>MpqOpenArchiveForUpdate</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">lpSourceFileName</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] A pointer to a <strong>NULL</strong>-terminated string containing the path of the file on disk to add. <strong>MpqAddWAVToArchive</strong> will crash if this is <strong>NULL</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">lpDestFileName</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] A pointer to a <strong>NULL</strong>-terminated string containing the name that the file will be given in the MPQ. <strong>MpqAddWAVToArchive</strong> will crash if this is <strong>NULL</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">dwFlags</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] Flags specifying properties that <strong>MpqAddWAVToArchive</strong> will apply to the file inside the MPQ. Must be a combination of the following flags specified in lmpqapi.h:</font></span></span> <table><tbody><tr><td><strong><span><span style="FONT-SIZE:x-small"><font size="1">MAFA_ENCRYPT</font></span></span></strong></td><td><span><span style="FONT-SIZE:x-small"><font size="1">The file will be encrypted.</font></span></span></td></tr><tr><td><strong><span><span style="FONT-SIZE:x-small"><font size="1">MAFA_REPLACE_EXISTING</font></span></span></strong></td><td><span><span style="FONT-SIZE:x-small"><font size="1">If the file <em>lpDestFileName</em> already exists in the MPQ, it will be replaced with the new file to be added</font></span></span></td></tr></tbody></table></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">dwQuality</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] Specifies the quality the WAV file will be compressed to. Must be one of the following values defined in lmpqapi.h:</font></span></span> <table><tbody><tr><td><strong><span><span style="FONT-SIZE:x-small"><font size="1">MAWA_QUALITY_HIGH</font></span></span></strong></td><td><font size="1"><span><span style="FONT-SIZE:x-small">Best sound quality, least compression. WAV </span></span><em><span><span style="FONT-SIZE:x-small">lpDestFileName</span></span></em><span><span style="FONT-SIZE:x-small"> in MPQ will occupy the most space after compression (but still less space than if you had added the file with MpqAddFileToArchive instead)</span></span></font></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><strong><font size="1">MAWA_QUALITY_MEDIUM</font></strong></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">Medium sound quality, medium compression. Balance between quality and compression.</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><strong><font size="1">MAWA_QUALITY_LOW</font></strong></span></span></td><td><font size="1"><span><span style="FONT-SIZE:x-small">Highest compression, worst sound quality. WAV </span></span><em><span><span style="FONT-SIZE:x-small">lpDestFileName</span></span></em><span><span style="FONT-SIZE:x-small"> in MPQ will occupy the least space after compression.</span></span></font></td></tr></tbody></table></td></tr></tbody></table></td></tr></tbody></table><br/>毫无疑问，最流行的新功能的lmpqapi 2.0版（就是我做的） ，便有功能 mpqaddwavtoarchive 。 <br/>虽然mpqaddfiletoarchive能压缩约80 ％的文件（非wav文件） ，它对WAV文件的压缩只有平均约5 ％ 。这是由于wav数据性质和它的不可压缩性。 <br/>在这里，对于wav压缩的压缩是必要的，而 mpqaddwavtoarchive就实现了这个功能。 <br/>尽管工作原理不同，MpqAddWAVToArchive的界面与 MpqAddFileToArchive却是几乎相同的。 <br/>唯一的区别就是多了一个新函数dwQuality。 <br/>参数设置后WAV将会被压缩。 <br/>不过不像mpqaddfiletoarchive的标准压缩， mpqaddwavtoarchive的wav压缩，实际上降低了wav的质量 。质量降低多少依赖于dwquality 。 <br/>如果您有一个音乐WAV而又想保证质量，那您就使用mawa_quality_high ，因为它最好的保留wav的质量；而同一个声音wav ， mawa_quality_low通常是不行的，因为声调比较容易压缩失真; mawa_quality_medium往往是最有效的。 <br/><br/><br/><span>Deleting a File - MpqDeleteFile <br/>删除文件函数 - MpqDeleteFile <br/></span><br/><br/><table><tbody><tr><td>&nbsp;</td><td colspan="2"><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>BOOL WINAPI MpqDeleteFile(HANDLE </strong><em><span>hMPQ</span></em><strong>, LPCSTR </strong><span><em>lpFileName</em></span></font></span><strong><span><font size="1">);<br/></font></span></strong></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">hMPQ</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The <strong>HANDLE</strong> of the MPQ to close, which was acquired earlier with <strong>MpqOpenArchiveForUpdate</strong>. <strong>MpqDelete</strong> will fail (or worse) if this is <strong>NULL</strong> or a <strong>HANDLE</strong> not obtained with <strong>MpqOpenArchiveForUpdate</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">lpFileName</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] A pointer to a <strong>NULL</strong>-terminated name of the file in the MPQ to delete. <strong>MpqDeleteFile</strong> will crash if this is <strong>NULL</strong>.</font></span></span></td></tr></tbody></table></td></tr></tbody></table><br/>少数情况下，您可能需要删除MPQ中的某个文件，那么您就需要用到MpqDeleteFile。 <br/>MpqDeleteFile能从已经打开的存档hMPQ中删除文件lpFileName。 <br/>不过这不是看上去那么简单的。 <br/>mpqdeletefile为lpfilename删除哈希和文件表项 ，使其无法进入。 <br/>但是除非文件在MPQ的physical end ，否则MpqDeleteFile无法清除内存。 <br/>这就是说，通常情况下MPQ文件是不会减小大小的。 <br/>不过空间可以添加新文件循环再利用。稍后为您介绍MpqAddFileToArchive 和MpqAddWAVToArchive. <br/><br/>就像STROM和STAREDIT几乎所有的功能一样，调用MpqDeleteFile成功就返回TURE，失败就返回FALSE。 <br/>失败的话，您可以调用GetLastError去获得一些关于失败原因的信息（假如有的话）。 <br/>在这种情况下GetLastError是惊人的有效。 <br/>因为几乎只有一种会造成MpqDeleteFile失败的原因（除了hMPQ无效）： <br/>该文件lpFileName不存在于MPQ，GetLastError将返回MPQ_ERROR_FILE_NOT_FOUND。 <br/><br/><br/><span>Renaming a File - MpqRenameFile <br/>重命名文件函数- MpqRenameFile</span> <br/><br/><br/><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>BOOL WINAPI MpqRenameFile(HANDLE </strong><em><span>hMPQ</span></em><strong>, LPCSTR </strong><span><em>lpOldFileName</em></span><strong>, LPCSTR </strong><span><em>lpNewFileName</em></span><strong>);</strong></font></span></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">hMPQ</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The <strong>HANDLE</strong> of the MPQ that holds the file to be renamed, and was acquired earlier with <strong>MpqOpenArchiveForUpdate</strong>. <strong>MpqRenameFile</strong> will fail if this is <strong>NULL</strong> or a <strong>HANDLE</strong> not obtained with <strong>MpqOpenArchiveForUpdate</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">lpOldFileName</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] A pointer to a <strong>NULL</strong>-terminated string containing the name of the file in the MPQ to be renamed. <strong>MpqRenameFile</strong> will fail if this is <strong>NULL</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">lpNewFileName</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] A pointer to a <strong>NULL</strong>-terminated string containing the name that the file <em>lpOldFileName</em> will be changed to. <strong>MpqRenameFile</strong> will fail if this is <strong>NULL</strong></font></span></span></td></tr></tbody></table></div><div><br/>在我慢慢研究MPQ后发现StarEdit缺少一对非常有用的功能。 <br/>而且那个时候我对与STROM和StarEdit的运做有了相当的了解，所以我决定写个自己的功能。 <br/>MpqRenameFile 非常的简单;它重新把hMPQ中的文件名 由lpOldFileName变为lpNewFileName. <br/><br/>mpqrenamefile返回给您的依旧是简单的信息。 <br/>mpqrenamefile返回true就成功，FLASH失败，并让您调用getlasterror获得失败的原因 。 <br/>如果hMPQ HANDLE 是NULL或无效，lpoldfilename或lpnewfilename是Null ， getlasterror将返回error_invalid_parameter 。 <br/>如果该文件lpoldfilename不存在于MPQ hMPQ中， getlasterror将返回mpq_error_file_not_found 。 <br/>如果该文件lpnewfilename已经存在mpq中 ， getlasterror将返回mpq_error_already_exists 。</div><div>&nbsp;</div><div>&nbsp;</div><div><p><span>Compacting an MPQ - MpqCompactArchive <br/>压缩MPQ函数- MpqCompactArchive <br/><br/></span></p><table><tbody><tr><td>&nbsp;</td><td colspan="2"><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>BOOL WINAPI MpqCompactArchive(HANDLE </strong><em><span>hMPQ</span></em><strong>, BOOL </strong><span><em>bFailOnBadFile</em></span><strong>);</strong></font></span></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">hMPQ</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The <strong>HANDLE</strong> of the MPQ to compact, which was acquired earlier with <strong>MpqOpenArchiveForUpdate</strong>. <strong>MpqCompactArchive</strong> will fail if this is <strong>NULL</strong> or a <strong>HANDLE</strong> not obtained with <strong>MpqOpenArchiveForUpdate</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">bFailOnBadFile</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] Explained below. Should usually be <strong>FALSE</strong></font></span></span></td></tr></tbody></table></td></tr></tbody></table><p><br/><br/>记得我刚才说过调用mpqdeletefile实际上并不删除文件;它只是使它们无法使用。那么， mpqaddfiletoarchive和mpqaddwavtoarchive也是一样。 <br/>当您添加一个已经存在的文件或添加比旧文件大的新文件，新的文件将附加，和原来被占用的空间不会被释放。正因为如此，每当您建立一个大的复杂的包含许多覆盖/删除的档案的mpq，将会有很大的体积，并且没有办法从零重建MPQ。 <br/><br/>解决这个问题的方法是调用mpqcompactarchive ：这是我设计的第三个，也是最后一个，最困难的mpq功能。 mpqcompactarchive的功能是把数据压缩到一个缓冲文件，然后再传回。这就是说在压缩的时候，在磁盘上的缓冲文件必须有足够的可用空间（这取决于MPQ的大小）。 <br/><br/>虽然mpqcompactarchive可以让几乎所有的文件变得紧凑，但是还是有不能成功的类型：有mafa_encrypt和mafa_modcryptkey属性，但缺乏mafa_compress和mafa_compress2属性的文件（如需详细资讯，请参阅第5章） 。当mpqcompactarchve调用这种文件，getlasterror会返回错误代码mpq_error_compact_error ，然后删除违规档案，并继续压缩过程。 <br/><br/>mpqcompactarchive返回TURE就成功，FLASH就失败。您可以调用getlasterror获得错误信息 。 <br/>如果hmpq是Null或无效的staredit HANDLE， getlasterror将返回error_invalid_parameter 。 <br/>如果没有足够的可用记忆体为mpqcompactarchive拨出2.5 MB的读取缓冲区， getlasterror将返回error_outofmemory 。 <br/>如果没有足够的可用磁盘空间mpqcompactarchive分配缓冲文件， GetLastError返回error_disk_full 。在某些特殊的情况下， getlasterror可能会返回其他一些奇怪的错误代码。 <br/><br/><br/><span>Getting Information About a File - SFileGetFileInfo <br/>获取文件有关信息函数 - SFileGetFileInfo</span> <br/><br/><br/></p><table><tbody><tr><td colspan="4" width="100%"><span style="FONT-SIZE:x-small"><span><font size="1"><strong>DWORD WINAPI SFileGetFileInfo(HANDLE </strong><em><span>hMPQ</span></em><span><em>orFile</em></span><strong>, DWORD </strong><span><em>dwInfoType</em></span></font></span><strong><span><font size="1">);<br/></font></span></strong></span></td></tr><tr><td width="5%">&nbsp;</td><td width="20%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">Parameter</font></span></span></span></em></strong></td><td width="70%"><strong><em><span style="TEXT-DECORATION:underline"><span><span style="FONT-SIZE:x-small"><font size="1">What it is</font></span></span></span></em></strong></td><td width="5%">&nbsp;</td></tr><tr><td>&nbsp;</td><td><span><span style="FONT-SIZE:x-small"><em><font size="1">hMPQorFile</font></em></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The <strong>HANDLE</strong> of the either the MPQ or file inside an MPQ to obtain info about, which was acquired earlier with either <strong>SFileOpenArchive or SFileOpenFileEx</strong>. <strong>SFileGetFileInfo</strong> will fail (or worse) if this is <strong>NULL</strong> or a <strong>HANDLE</strong> not obtained with <strong>SFileOpenArchive</strong> or <strong>SFileOpenFileEx</strong>.</font></span></span></td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><em><span><span style="FONT-SIZE:x-small"><font size="1">dwInfoType</font></span></span></em></td><td><span><span style="FONT-SIZE:x-small"><font size="1">[in] The type of info to obtain about the file or MPQ. Must be one of the following values defined in lmpqapi.h:</font></span></span> <table><tbody><tr><td><span><span style="FONT-SIZE:x-small"><strong><font size="1">SFILE_INFO_HASH_TABLE_SIZE</font></strong></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1"><strong>SFileGetFileInfo</strong> will return the hash table size of <em>hMPQorFile</em> (see chapters </font><a href="http://www.campaigncreations.org/starcraft/inside_mopaq/chapter2.htm" target="_blank"><span style="COLOR:#0556d0"><font size="1">2</font></span></a><font size="1"> and </font><a href="http://www.campaigncreations.org/starcraft/inside_mopaq/chapter5.htm" target="_blank"><span style="COLOR:#0556d0"><font size="1">5</font></span></a><font size="1"> for more info). <em>hMPQorFile</em> must be a <strong>HANDLE</strong> of an MPQ.</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><strong><font size="1">SFILE_INFO_NUM_FILES</font></strong></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1"><strong>SFileGetFileInfo</strong> will return the number of files inside <em>hMPQorFile</em>. <em>hMPQorFile</em> must be a <strong>HANDLE</strong> of an MPQ.</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><strong><font size="1">SFILE_INFO_SIZE</font></strong></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1"><strong>SFileGetFileInfo</strong> will return the size of the MPQ <em>hMPQorFile</em> or the uncompressed size of the file <em>hMPQorFile</em>. This is functionally equivalent to the <strong>SFileGetFileSize</strong> function. <em>hMPQorFile</em> can be either a <strong>HANDLE</strong> of an MPQ or a <strong>HANDLE</strong> of a file inside.</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><strong><font size="1">SFILE_INFO_COMPRESSED_SIZE</font></strong></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1"><strong>SFileGetFileInfo</strong> will return the compressed size (or uncompressed size if the file isn't compressed) of the file <em>hMPQorFile</em> in an MPQ. <em>hMPQorFile</em> must be a <strong>HANDLE</strong> of a file inside an MPQ.</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><strong><font size="1">SFILE_INFO_FLAGS</font></strong></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1"><strong>SFileGetFileInfo</strong> will return the flags (see </font><a href="http://www.campaigncreations.org/starcraft/inside_mopaq/chapter5.htm" target="_blank"><span style="COLOR:#0556d0"><font size="1">chapter 5</font></span></a><font size="1"> for the meaning of specific flags) of the file <em>hMPQorFile</em> in an MPQ. <em>hMPQorFile</em> must be a <strong>HANDLE</strong> of a file inside an MPQ.</font></span></span></td></tr><tr><td><span><span style="FONT-SIZE:x-small"><strong><font size="1">SFILE_INFO_POSITION</font></strong></span></span></td><td><span><span style="FONT-SIZE:x-small"><font size="1"><strong>SFileGetFileInfo</strong> will return the absolute position of the file pointer for the file <em>hMPQorFile</em> in an MPQ. <em>hMPQorFile</em> must be a <strong>HANDLE</strong> of a file inside an MPQ.</font></span></span></td></tr></tbody></table></td></tr></tbody></table><p><br/><br/>SFileGetFileInfo 是 LMPQAPI中最古怪的功能函数. <br/>不仅是唯一可以通过LMPQAPI而不能通过STROM接口库的STROM功能。 <br/>它唯一的函数就是能够接受MPQ或者文件HANDLE，但在大多数情况下它根本不存在于STROM里。 <br/>为了补救这个，我自己写了了这个SFileGetFileInfo。 <br/><br/>sfilegetfileinfo是专门设计来提供有用的mpq和其内档案的信息;包括mpq中压缩文件的大小，文件指针的位置。它使用简单，但相当有效。它使用已经打开了的mpq或文件的HANDLE，以获取有关hmpqorfile的信息 ，以及在dwinfotype中需要的信息类型代码。 <br/><br/>如果sfilegetfileinfo成功，返回值就是有关文件或MPQ的资料 。 <br/>但是，如果失败的话，它会返回0xFFFFFFFF，并设置一个错误代码，您可以调用getlasterror查看 。 <br/>如果因为hmpqorfile HANDLE是无效的， getlasterror将返回error_invalid_parameter 。 <br/>如果因为dwinfotype是一个无效的信息代码，getlasterror将返回error_unknown_property 。 sfilegetfileinfo只在一种情况下会调用失败（除了严重的内部lmpqapi错误）。 <br/>因为一个mpq HANDLE和dwinfotype指定的信息只能得到一个文件HANDLE，或反之亦然，在这种情况下， getlasterror将返回error_unknown_property。</p></div></td></tr></tbody></table></div></div>

				</article>
			</div>
		</div>
	    <footer>
			<div class="owner">
				<p><a href="https://github.com/firstfhy" class="avatar"><img src="https://avatars0.githubusercontent.com/u/10542465?v=3&amp;s=60" width="48" height="48"></a>View <a href="https://github.com/firstfhy">firstfhy</a> on <a href="https://www.github.com">GitHub</a></p>
			</div>
			<div class="creds">
			  	<small>This page generated using <a href="http://pages.github.com/">GitHub Pages</a><br>theme by <a href="https://twitter.com/jonrohan/">Jon Rohan</a></small>
			</div>
	    </footer>
	</div>
</body>
</html>
